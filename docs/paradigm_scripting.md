# Paradigm Scripting

## Introduction

The paradigm is programmed via a so-called _paradigm file_. A paradigm file contains regular Python code and must define the **Paradigm class**, which must derive from the **ParadigmBase parent class**. Its code is automatically loaded when YAGA starts. A typical skeleton looks like this:

``` Python
from yaga_modules.paradigm_base import ParadigmBase
import yaga_modules.graphic_objects as GO
import yaga_modules.audio_objects as AO
import yaga_modules.signal_processing as SP

class Paradigm(ParadigmBase):
    def __init__(self, paradigm_variables):
        super().__init__(paradigm_variables)
        […]
```

### Creation of a Presentation Objects

YAGA supports the timed presentation of several graphical or auditory objects, e.g., text, circles, or beep tones. A presentation object needs to be created within the **\_\_init\_\_** constructor of the **Paradigm class** and registered to YAGA. A simple text object can be created as:

``` Python
info_text = self.registerObject(GO.Text('prepare for task'))
```

In this example, **GO.Text** refers to the **Text class** defined in the **graphic_objects module** (GO). The call of **registerObject** is obligatory and registers the object to YAGA.

### Timing of Presentation Objects

Once an object has been created and registered, state changes of the object can be scripted, i.e., timed. For that purpose, the **ParadigmBase parent class** provides the instance variable **script**. **script** must be a list of **ScriptItem** objects.

A **ScripItem** object specifies:

1. a list of actions to execute when triggered
2. the trigger (time, signal or LSL event marker)
3. an informative name which is sent as an LSL event marker when the **ScriptItem** is triggered

### Demo Paradigm

The paradigm _demo.py_ implements a simple paradigm where study participants execute a task after a Go cue. The paradigm shows an instruction text and a traffic light on the screen. The traffic light represents the Go cue. After the traffic light, a countdown starts. While the countdown is running, the study participants would be asked to execute a certain task. The demo paradigm file shows the creation of text, image, and countdown objects and the set up of the paradigm sequence with script items.

A trial comprises the following script items: _“trial_start”_, _“traffic_ligh_red”_, _“traffic_ligh_yellow”_, _“traffic_ligh_green”_, _“countdown”_, _“trial_end”_. All script items are executed sequentially. Each script item optionally specifies the actions to be executed when the script item is triggered. Note that the actions must be specified as objects, not as actual method calls (i.e., no parentheses). The **script** list contains a total of 5 trial sequences, and is built using a for loop.

The demo paradigm file demonstrates three possible trigger types: **absolute time**, **relative time**, and **signal-based**. An absolute time trigger is used by the first _“trial_start”_ script item, which is triggered 3s after program start. The subsequent _“trial_start”_ script items use a relative time trigger, and are triggered 5s to 10s after the previous _“trial_end”_ script item. A relative time trigger is specified by setting the _time_type_ property to _"rel"_ and the _rel_name_ property to the name of the referenced script item. A signal-based trigger is used by the _“trial_end”_ script item. This script item is triggered when the countdown object elicits the signal specified by the _“wait_for_signal”_ property (_COUNTDOWN_FINISHED_).

The full source code of the demo paradigm file:

``` Python
{!paradigms/demo.py!}
```

## Script Items

The paradigm sequence is defined by _script items_, which must be listed in the **script** instance variable of your **Paradigm** class. The script items are processed one by one in the order in which they appear in the instance variable **script**. A script item can be triggered by a **time event**, by a **signal event** generated by a graphical object, or by an external **LSL marker event**. You can also combine different trigger types. The script item is then triggered by whichever event comes first. A script item can be defined as:

``` Python
ScriptItem(name='trial_start', time=10, actions=[info_text.activate])
```

In this example, the script item will call the method **activate** on the graphical object **info_text** at second 10 after the program start.

The name of the script item is sent as an event marker in the LSL stream _yaga_ when the item is triggered. This allows recording programs to save the paradigm state together with the LSL data streams (see [Integration with LSL](integration_with_lsl.md)).

Note that the execution of script items is synchronised to the screen refresh rate (often 60 Hz).

### Actions

The actions parameter of a **ScriptItem** expects a list of methods which are called when the action item is triggered. The available actions depend on the presentation object and are listed in [Supported Graphical Objects](paradigm_scripting.md#supported-graphical-objects) and [Auditory Objects](paradigm_scripting.md#auditory-objects).

The actions must be specified as objects and not as method calls, i.e., without subsequent parentheses. This is to ensure that actions are executed when the script item is triggered and not at the program start when the initialisation method is executed.

Some actions accept parameters. You can specify parameters by using the **partial function** from the **functools module**. The **partial function** allows to fix arguments and generates a new function object. This new function object is then executed when the action item is triggered.

First import **partial**:

``` Python
from functools import partial
```

Then use **partial** to create a new function object with a fixed set of parameters, e.g.:

``` Python
ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)])
```

In this example, **targets.setActiveTarget(1)** is executed when the script item is triggered.

### Time Triggers

YAGA supports two types of time triggers: **absolute time triggers** and **relative time triggers**. A trigger specified with an absolute time is triggered at the specified time after the program start. A trigger specified with a relative time is triggered at the specified time relative to another script item.

An absolute time trigger is the default. For example, to trigger a script item 10s after the program start, write:

``` Python
ScriptItem(name='trial_start', time=10, actions=[info_text.activate])
```

To specify a relative time trigger, set _time_type_ to _“rel”_ and provide the name of the reference event with _rel_name_. For example, to trigger a script item 5s to 10s after the last “trial_end” event, write:

``` Python
ScriptItem(name='trial_start', time=np.random.uniform(5, 10), time_type='rel', rel_name='trial_end', actions=[info_text.activate\])]
```

### Signal Triggers

A script item can wait for trigger signals generated by graphical objects. To trigger a script item with a signal, set _wait_for_signal_ to the respective signal. The possible trigger signals are listed in [Supported Graphical Objects](paradigm_scripting.md#supported-graphical-objects). For example:

``` Python
ScriptItem(name='trial_end', wait_for_signal=GO.Countdown.COUNTDOWN_FINISHED, actions=[])
```

### LSL Event Marker Triggers

A script item can be triggered by an external _LSL event marker_ generated by other programs. To listen to an LSL event marker stream, call the method **listenForLSLMarkers** in the paradigm file. For example, to listen for markers in the first channel of the stream _streamA_:

``` Python
self.listenForLSLMarkers("streamA", lsl_marker_channel=0)
```

The streams are expected to be event marker streams, i.e., they have an irregular sampling rate. The markers are usually variable-length ASCII strings.

After setting up an LSL event listener, you can trigger script items on LSL events by specifying the marker with the parameter _wait_for_lsl_marker_. For example:

``` Python
ScriptItem(name='trial_end', wait_for_lsl_marker=”target_reached”, actions=[])
```

The data type of the specified marker must correspond to the data type of the LSL stream (usually a _string_).

## Command Line Variables

YAGA supports three general-purpose variables, which can be specified when you start YAGA.py (_var1_, _var2_, _var3_). For example:

`python yaga.py --paradigm YOURPARADIGM --var1 someStringOrNumber`

The general purpose variables are accessible in the paradigm file:

``` Python
class Paradigm(ParadigmBase):

    def __init__(self, paradigm_variables):

        var1 = paradigm_variables['var1']
```

Moreover, one can specify the subject code (_string_) and session number (_integer_) with the command line parameters `--subject` and `--session`, respectively. These parameters are accessible as `paradigm_variables['subject']` and `paradigm_variables['session']` in the paradigm file.

## Graphical Objects

Graphical objects are objects shown on the computer screen, such as text or feedback bars. They can be [controllable](paradigm_scripting.md#control-of-graphical-objects) with LSL streams, and can feature animations.

To use graphical objects, import the **graphic_objects module**:

``` Python
import yaga_modules.graphic_objects as GO
```

A graphical object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a text object:

``` Python
text = self.registerObject(GO.Text('prepare for task'))
```

### Base Methods

All graphical objects support the following methods which can be specified as actions in a **ScriptItem**:

| method     | parameters | value type | description           |
|------------|------------|------------|-----------------------|
| activate   | -          | -          | show object on screen |
| deactivate | -          | -          | hide object on screen |

The position, scale, angle, and color of graphical objects can be changed with the following methods:

| method      | parameters          | value types             | description                |
|-------------|---------------------|-------------------------|----------------------------|
| updatePos   | pos_x, pos_y, depth | double, double, integer | set x/y position and depth |
| updateScale | scale_x, scale_y    | double, double          | set x/y size               |
| updateRot   | angle               | double                  | rotate object (in degrees) |
| updateColor | color               | string or 3-tuple       | set color                  |

### Screen Units

Position values are in screen units and are independent of the monitor resolution. The centre of the screen corresponds to the x/y position 0. The bottom edge corresponds to a y-position of -1. The top edge corresponds to an y-position of 1. The x-positions of the left and right edges depend on the screen ratio. With a typical screen ratio of 16:9, the left and right edges have the x-positions -1.78 and 1.78, respectively ((y<sub>top</sub> - y<sub>center</sub>) x 16/9).

### Depth of Objects

The depth parameter must be an integer value and specifies the depth position of objects. Objects with a smaller depth value are in front of objects with a higher depth value (the default depth is 0).

### Colour of Objects

Many objects allow changing their colour. The colour must be specified as an RGB tuple with values from (0, 0, 0) to (255, 255, 255) or as a colour name (_string_). The following color names are supported: _black, white, red, lime, blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy, gold, orange,_ and _darkorange_.

### Animated Objects

Some graphical objects support animations. Animations can be started or stopped using an action (**startAnimation**, **stopAnimation**) in a **ScriptItem**. Furthermore, animations can generate signals which can be used as triggers for **ScriptItems** (e.g., trigger actions at the end of an animation).

### Supported Graphical Objects

Typical graphical elements used in neuroscience experiments are implemented. The Python classes representing these elements are described in the following.

#### Image Class

Loads an image file from the hard disk and displays it on the computer screen. The image must be in the subfolder _resources/images_. All common image formats are supported.

_Object Initialisation Parameters:_

| parameter | value type | description         |
|-----------|------------|---------------------|
| file      | string     | file name of image  |
| pox_x     | double     | horizontal position |
| pos_y     | double     | vertical position   |
| depth     | integer    | depth position      |
| scale_x   | double     | horizontal size     |
| scale_y   | double     | vertical size       |
| angle     | double     | rotation angle      |

#### Ball Class

Displays a filled circle on the computer screen.

![ball](images/ball.png)

_Object Initialisation Parameters:_

| parameter | value type        | description         |
|-----------|-------------------|---------------------|
| pox_x     | double            | horizontal position |
| pos_y     | double            | vertical position   |
| depth     | integer           | depth position      |
| scale_x   | double            | horizontal size     |
| scale_y   | double            | vertical size       |
| color     | string or 3-tuple | fill color          |

#### Box Class

Displays a filled box on the computer screen.

![box](images/box.png)

_Object Initialisation Parameters:_

| parameter | value type        | description         |
|-----------|-------------------|---------------------|
| pox_x     | double            | horizontal position |
| pos_y     | double            | vertical position   |
| depth     | integer           | depth position      |
| scale_x   | double            | horizontal size     |
| scale_y   | double            | vertical size       |
| angle     | double            | rotation angle      |
| color     | string or 3-tuple | fill color          |

#### Cross Class

Displays a cross on the screen.

![cross](images/cross.png)

_Object Initialisation Parameters:_

| parameter  | value type        | description         |
|------------|-------------------|---------------------|
| line_width | double            | cross line size     |
| pox_x      | double            | horizontal position |
| pos_y      | double            | vertical position   |
| depth      | integer           | depth position      |
| scale_x    | double            | horizontal size     |
| scale_y    | double            | vertical size       |
| angle      | double            | rotation angle      |
| color      | string or 3-tuple | cross color         |

#### Text Class

Displays a text box on the computer screen. Optionally, a value can be read from an LSL stream and displayed on the screen as a rounded number.

![text](images/text.png)

To read a number from an LSL stream, call the method _controlStateWithLSLStream_. For example:

``` Python
text = self.registerObject(GO.Text())
text.controlStateWithLSLStream(“the-stream”, channels=[1])
```

_Object Initialisation Parameters:_

| parameter        | value type        | description               |
|------------------|-------------------|---------------------------|
| text             | string            | text to display           |
| pox_x            | double            | horizontal position       |
| pos_y            | double            | vertical position         |
| depth            | integer           | depth position            |
| scale_x          | double            | horizontal size           |
| scale_y          | double            | vertical size             |
| angle            | double            | rotation angle            |
| color            | string or 3-tuple | text color                |
| background_color | string or 3-tuple | text box background color |
| frame_color      | string or 3-tuple | text box frame color      |

_ScriptItem Actions:_

| method                | parameters | value types       | description                   |
|-----------------------|------------|-------------------|-------------------------------|
| updateColor           | color      | string or 3-tuple | set text color                |
| updateBackgroundColor | color      | string or 3-tuple | set text box background color |
| updateFrameColor      | color      | string or 3-tuple | set text box frame color      |
| updateText            | text       | string            | set text                      |

#### RandomNumber Class

Display a random number in a text box on the computer screen. The number is updated after each call of the method **activate** according to a discrete normal distribution.

![random number](images/rnd.png)

_Object Initialisation Parameters:_

| parameter        | value type         | description                                                 |
|------------------|--------------------|-------------------------------------------------------------|
| interval         | list of 2 integers | a random number is drawn from the specified closed interval |
| pox_x            | double             | horizontal position                                         |
| pos_y            | double             | vertical position                                           |
| depth            | integer            | depth position                                              |
| scale_x          | double             | horizontal size                                             |
| scale_y          | double             | vertical size                                               |
| angle            | double             | rotation angle                                              |
| color            | string or 3-tuple  | text color                                                  |
| background_color | string or 3-tuple  | text box background color; set to None to deactivate        |
| frame_color      | string or 3-tuple  | text box frame color; set to None to deactivate             |

#### Countdown Class

An animated countdown is displayed in a text box on the computer screen. The countdown is restarted after each call of the method **activate**.

![countdown](images/countdown.png)

_Object Initialisation Parameters:_

| parameter        | value type        | description                    |
|------------------|-------------------|--------------------------------|
| counter_start    | integer           | initial value of the countdown |
| counter_stop     | integer           | final value of the countdown   |
| counter_interval | double            | interval time in seconds       |
| pox_x            | double            | horizontal position            |
| pos_y            | double            | vertical position              |
| depth            | integer           | depth position                 |
| scale_x          | double            | horizontal size                |
| scale_y          | double            | vertical size                  |
| angle            | double            | rotation angle                 |
| color            | string or 3-tuple | text color                     |
| background_color | string or 3-tuple | text box background color      |
| frame_color      | string or 3-tuple | text box frame color           |

_ScriptItem Trigger Signals:_

| signal                       | description                          |
|------------------------------|--------------------------------------|
| Countdown.COUNTDOWN_FINISHED | elicited at the end of the countdown |

#### Bar Class

Displays a bar for 1D feedback on the screen. The fill level of the bar is controlled with a channel from an LSL stream. Optionally, a horizontal target line can be specified. The target line position can be fixed at object initialization, updated with a call of **updateTargetValue**, or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter _target_online_control_) or updated at discrete time points with the action **updateTargetValueFromLSLStream**.

![bar](images/bar.png)

To set up the control of the fill level, call the method **controlStateWithLSLStream** and specify one control channel. For example:

``` Python
bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0))
bar.controlStateWithLSLStream(“the-stream”, channels=[0])
```

To optionally control the vertical target position continuously with the same LSL stream, set _target_online_control_ to _true_, and specify a second control channel. For example:

``` Python
bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true))
bar.controlStateWithLSLStream(“the-stream”, channels=[0, 1])
```

The vertical target position can also be controlled with a separate LSL stream by using **controlStateWithLSLStream<u>s</u>**. The second specified channel then refers to the second stream. For example:

``` Python
bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true))
bar.controlStateWithLSLStream([“stream-A”, "stream-B"], channels=[0, 1])
```

Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action **updateTargetValueFromLSLStream** in the respective **ScriptItem** objects. Note that you still need to set up the control with **controlStateWithLSLStream** or **controlStateWithLSLStreams**.
For example:

``` Python
bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=false))
bar.controlStateWithLSLStream(“the-stream”, channels=[0, 1])

[...]

ScriptItem(name='update_bar', time=10, actions=[bar.updateTargetValueFromLSLStream])
```

_Object Initialisation Parameters:_

| parameter             | value type        | description                                                                                                               |
|-----------------------|-------------------|---------------------------------------------------------------------------------------------------------------------------|
| pox_x                 | double            | horizontal position                                                                                                       |
| pos_y                 | double            | vertical position                                                                                                         |
| depth                 | integer           | depth position                                                                                                            |
| bar_width             | double            | width of the bar                                                                                                          |
| bar_height            | double            | height of the bar when fully raised                                                                                       |
| frame_width           | double            | thickness of the frame around the bar                                                                                     |
| target_width          | double            | width of the target line                                                                                                  |
| target_height         | double            | height of the target line                                                                                                 |
| bar_color             | string or 3-tuple | color of the bar                                                                                                          |
| frame_color           | string or 3-tuple | color of the bar frame                                                                                                    |
| target_color          | string or 3-tuple | color of the target line                                                                                                  |
| low_value             | double            | LSL value corresponding to an empty bar                                                                                   |
| high_value            | double            | LSL value corresponding to a fully filled bar                                                                             |
| target_value          | double            | - target value or fill level (_low_value_ <= target <= _high_value_) <br> - if set to _None_, no target will be displayed |
| target_online_control | bool              | - if _true_ control the vertical target position continuously with an LSL stream <br> - a second control channel for the target position must be specified when calling **controlStateWithLSLStream** or **controlStateWithLSLStreams** <br> - if _false_, the target position can be updated with the action **updateTargetValueFromLSLStream** |

_ScriptItem Actions:_

| method                         | parameters   | value types | description                                                                                                                                    |
|--------------------------------|--------------|-------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| updateTargetValue              | target_value | double      | update the target value                                                                                                                        |
| updateTargetValueFromLSLStream | -            | -           | - update the target value with the most recent value from an LSL stream <br> - it is necessary to call **controlStateWithLSLStream(s)** before |

#### BarWithRampTarget Class

Displays a feedback [bar]](paradigm_scripting.md#bar-class) with a ramp animation of the target. The target will transit through the following phases:

1.  pre phase: target line is at the initial position
2.  ramp up phase: target line moves upwards
3.  hold phase: target line is at the hold position
4.  ramp down phase: target line moves downwards
5.  post phase: target line is back to the initial position

An additional horizontal line indicating the final ramp target will be displayed (target information) if the target animation is configured to stop below the top of the bar.

_Object Initialisation Parameters:_

| parameter                | value type        | description                                       |
|--------------------------|-------------------|---------------------------------------------------|
| pox_x                    | double            | horizontal position                               |
| pos_y                    | double            | vertical position                                 |
| depth                    | integer           | depth position                                    |
| bar_width                | double            | width of the bar                                  |
| bar_height               | double            | height of the bar when fully raised               |
| frame_width              | double            | thickness of the frame around the bar             |
| target_width             | double            | width of the target line                          |
| target_height            | double            | height of the target line                         |
| bar_color                | string or 3-tuple | color of the bar                                  |
| frame_color              | string or 3-tuple | color of the bar frame                            |
| target_color             | string or 3-tuple | color of the target line                          |
| target_info_color        | string or 3-tuple | color of the target information                   |
| pre_phase_duration       | double            | time duration of the pre phase                    |
| ramp_up_phase_duration   | double            | time duration of the ramp up phase                |
| hold_phase_duration      | double            | time duration of the hold phase                   |
| ramp_down_phase_duration | double            | time duration of the ramp down phase              |
| post_phase_duration      | double            | time duration of the post phase                   |
| low_value                | double            | LSL value corresponding to a fully contracted bar |
| high_value               | double            | LSL value corresponding to a fully raised bar     |
| start_value              | double            | the initial position of the target                |
| ramp_value               | double            | the position of the target in the hold phase      |

_ScriptItem Actions:_

| method            | parameters   | value types | description             |
|-------------------|--------------|-------------|-------------------------|
| updateTargetValue | target_value | double      | update the target value |
| startAnimation    | -            | -           | start ramp animation    |
| stopAnimation     | -            | -           | stop ramp animation     |

_ScriptItem Trigger Signals:_

| signal                         | description                              |
|--------------------------------|------------------------------------------|
| BarWithRampTarget.BAR_FINISHED | elicited after the end of the post phase |

#### BarWithSinusTarget Class

Displays a feedback [bar](paradigm_scripting.md#bar-class) with a sinus oscillation animation of the target. The target will transit through the following phases:

1.  pre phase: target line is at the initial position
2.  ramp up phase: target line moves upwards
3.  sinus phase: target line oscillates up and down
4.  ramp down phase: target line moves downwards
5.  post phase: target line is back to the initial position

An additional horizontal line indicating the oscillation center will be displayed (target information) if the oscillation center is configured to be below the top of the bar.

_Object Initialisation Parameters:_

| parameter                | value type        | description                                       |
|--------------------------|-------------------|---------------------------------------------------|
| pox_x                    | double            | horizontal position                               |
| pos_y                    | double            | vertical position                                 |
| depth                    | integer           | depth position                                    |
| bar_width                | double            | width of the bar                                  |
| bar_height               | double            | height of the bar when fully raised               |
| frame_width              | double            | thickness of the frame around the bar             |
| target_width             | double            | width of the target line                          |
| target_height            | double            | height of the target line                         |
| bar_color                | string or 3-tuple | color of the bar                                  |
| frame_color              | string or 3-tuple | color of the bar frame                            |
| target_color             | string or 3-tuple | color of the target line                          |
| target_info_color        | string or 3-tuple | color of the target information                   |
| pre_phase_duration       | double            | time duration of the pre phase                    |
| ramp_up_phase_duration   | double            | time duration of the ramp up phase                |
| sinus_phase_duration     | double            | time duration of the oscillation phase            |
| sinus_frequency          | double            | oscillation frequency in Hz                       |
| sinus_amplitude          | double            | oscillation amplitude                             |
| ramp_down_phase_duration | double            | time duration of the ramp down phase              |
| post_phase_duration      | double            | time duration of the post phase                   |
| low_value                | double            | LSL value corresponding to a fully contracted bar |
| high_value               | double            | LSL value corresponding to a fully raised bar     |
| start_value              | double            | the initial position of the target                |
| ramp_value               | double            | the center position of the sinus oscillations     |

_ScriptItem Actions:_

| method            | parameters   | value types | description             |
|-------------------|--------------|-------------|-------------------------|
| updateTargetValue | target_value | double      | update the target value |
| startAnimation    | -            | -           | start ramp animation    |
| stopAnimation     | -            | -           | stop ramp animation     |

_ScriptItem Trigger Signals:_

| signal                          | description                              |
|---------------------------------|------------------------------------------|
| BarWithSinusTarget.BAR_FINISHED | elicited after the end of the post phase |

#### Arrow Class

Displays an arrow for 2D feedback on the computer screen. The endpoint of the arrow is controlled with two channels from an LSL stream. Optionally, a target can be visualised as a disk above the arrow's origin. The vertical target position can be fixed at object initialization, updated with a call of **updateTargetValue**, or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter _target_online_control_) or updated at discrete time points with the action **updateTargetValueFromLSLStream**.

![arrow](images/arrow.png)

To set up the control of the arrow’s endpoint, call the method **controlStateWithLSLStream** and specify the LSL stream and two control channels. For example:

``` Python
arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1])
```

To optionally control the vertical target position continuously with the same LSL stream, set _target_online_control_ to _true_, and specify a third control channel. For example:

``` Python
arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])
```

The vertical target position can also be controlled with a separate LSL stream by using **controlStateWithLSLStream<u>s</u>**. The third specified channel then refers to the second stream. For example:

``` Python
arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true))
arrow.controlStateWithLSLStreams([“stream-A”, "stream-B"], channels=[0, 1, 0])
```

Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action **updateTargetValueFromLSLStream** in the respective **ScriptItem** objects. Note that you still need to set up the control with **controlStateWithLSLStream** or **controlStateWithLSLStreams**.
For example:

``` Python
arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=false))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])

[...]

ScriptItem(name='update_arrow', time=10, actions=[arrow.updateTargetValueFromLSLStream])
```

_Object Initialisation Parameters:_

| parameter             | value type        | description                                                                                    |
|-----------------------|-------------------|------------------------------------------------------------------------------------------------|
| pox_x                 | double            | horizontal position                                                                            |
| pos_y                 | double            | vertical position                                                                              |
| depth                 | integer           | depth position                                                                                 |
| angle                 | double            | rotation angle of the arrow                                                                    |
| arrow_length          | double            | length of the arrow when fully extended                                                        |
| line_width            | double            | width of the arrow                                                                             |
| head_size             | double            | head size of the arrow                                                                         |
| target_size           | double            | size of the target                                                                             |
| arrow_color           | string or 3-tuple | color of the arrow                                                                             |
| target_color          | string or 3-tuple | color of the target                                                                            |
| low_value             | double            | LSL value corresponding to a fully contracted arrow                                            |
| high_value            | double            | LSL value corresponding to a fully extended arrow                                              |
| target_value          | double            | - target value (vertical target position) <br> - if set to _None_, no target will be displayed |
| target_online_control | bool              | - if _true_, control the vertical target position continuously with an LSL stream <br> - a third control channel for the target position must be specified when calling **controlStateWithLSLStream** or **controlStateWithLSLStreams** <br> - if _false_, the target position can be updated with the action **updateTargetValueFromLSLStream** |

_ScriptItem Actions:_

| method                         | parameters   | value types | description                                                                                                                                     |
|--------------------------------|--------------|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| updateTargetValue              | target_value | double      | update the target value                                                                                                                         |
| updateTargetValueFromLSLStream | -            | -           | - update the target value with the most recent value from an LSL stream <br> - it is necessary to call **controlStateWithLSLStream(s)*** before |

#### ArrowWithRampTarget Class

Displays a feedback [arrow](paradigm_scripting.md#arrow-class) with a ramp animation of the target disk. The target will transit through the following phases:

1.  pre phase: target disk is at the initial position
2.  ramp up phase: target disk moves upwards
3.  hold phase: target disk is at the final position
4.  ramp down phase: target disk moves downwards
5.  post phase: target disk is back to the initial position

An additional disk indicating the final ramp target position will be displayed (target information).

_Object Initialisation Parameters:_

| parameter                | value type        | description                                                                                                                                       |
|--------------------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| pox_x                    | double            | horizontal position                                                                                                                               |
| pos_y                    | double            | vertical position                                                                                                                                 |
| depth                    | integer           | depth position                                                                                                                                    |
| angle                    | double            | rotation angle                                                                                                                                    |
| arrow_length             | double            | length of the arrow when fully extended                                                                                                           |
| line_width               | double            | width of the arrow                                                                                                                                |
| head_size                | double            | head size of the arrow                                                                                                                            |
| target_size              | double            | size of the target                                                                                                                                |
| target_info_size         | double            | size of the target information                                                                                                                    |
| arrow_color              | string or 3-tuple | color of the arrow                                                                                                                                |
| target_color             | string or 3-tuple | color of the target                                                                                                                               |
| target_info_color        | string or 3-tuple | color of the target information                                                                                                                   |
| pre_phase_duration       | double            | time duration of the pre phase                                                                                                                    |
| ramp_up_phase_duration   | double            | time duration of the ramp up phase                                                                                                                |
| hold_phase_duration      | double            | time duration of the hold phase                                                                                                                   |
| ramp_down_phase_duration | double            | time duration of the ramp down phase                                                                                                              |
| post_phase_duration      | double            | time duration of the post phase                                                                                                                   |
| low_value                | double            | LSL value corresponding to a fully contracted arrow                                                                                               |
| high_value               | double            | LSL value corresponding to a fully extended arrow                                                                                                 |
| start_value              | double            | the initial position of the target                                                                                                                |
| ramp_value               | double            | - the center position of the sinus oscillation <br> - when this value is lower than the _high_value_, an additional hold target will be displayed |

_ScriptItem Actions:_

| method            | parameters   | value types | description             |
|-------------------|--------------|-------------|-------------------------|
| updateTargetValue | target_value | double      | update the target value |
| startAnimation    | -            | -           | start ramp animation    |
| stopAnimation     | -            | -           | stop ramp animation     |

_ScriptItem Trigger Signals:_

| signal                                 | description                              |
|----------------------------------------|------------------------------------------|
| ArrowWithRampTarget.BAR_ARROW_FINISHED | elicited after the end of the post phase |

#### ArrowWithSinusTarget Class

Displays a feedback [arrow Class](paradigm_scripting.md#arrow-class) with a ramp animation of the target disk. The target will transit through the following phases:

1.  pre phase: target disk is at the initial position
2.  ramp up phase: target disk moves upwards
3.  sinus phase: target disk is oscillating up & down
4.  ramp down phase: target disk moves downwards
5.  post phase: target disk is back to the initial position

An additional disk indicating the position of the oscillation centre will be displayed (target information).

_Object Initialisation Parameters:_

| parameter                | value type        | description                                                                                                                                       |
|--------------------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| pox_x                    | double            | horizontal position                                                                                                                               |
| pos_y                    | double            | vertical position                                                                                                                                 |
| depth                    | integer           | depth position                                                                                                                                    |
| angle                    | double            | rotation angle                                                                                                                                    |
| arrow_length             | double            | length of the arrow when fully extended                                                                                                           |
| line_width               | double            | width of the arrow                                                                                                                                |
| head_size                | double            | head size of the arrow                                                                                                                            |
| target_size              | double            | size of the target                                                                                                                                |
| target_info_size         | double            | size of the target information                                                                                                                    |
| arrow_color              | string or 3-tuple | color of the arrow                                                                                                                                |
| target_color             | string or 3-tuple | color of the target                                                                                                                               |
| target_info_color        | string or 3-tuple | color of the target information                                                                                                                   |
| pre_phase_duration       | double            | time duration of the pre phase                                                                                                                    |
| ramp_up_phase_duration   | double            | time duration of the ramp up phase                                                                                                                |
| sinus_phase_duration     | double            | time duration of the oscillation phase                                                                                                            |
| sinus_frequency          | double            | oscillation frequency in Hz                                                                                                                       |
| sinus_amplitude          | double            | oscillation amplitude                                                                                                                             |
| ramp_down_phase_duration | double            | time duration of the ramp down phase                                                                                                              |
| post_phase_duration      | double            | time duration of the post phase                                                                                                                   |
| low_value                | double            | LSL value corresponding to a fully contracted arrow                                                                                               |
| high_value               | double            | LSL value corresponding to a fully extended arrow                                                                                                 |
| start_value              | double            | the initial position of the target                                                                                                                |
| ramp_value               | double            | - the center position of the sinus oscillation <br> - when this value is lower than the _high_value_, an additional hold target will be displayed |

_ScriptItem Actions:_

| method            | parameters   | value types | description             |
|-------------------|--------------|-------------|-------------------------|
| updateTargetValue | target_value | double      | update the target value |
| startAnimation    | -            | -           | start ramp animation    |
| stopAnimation     | -            | -           | stop ramp animation     |

_ScriptItem Trigger Signals:_

| signal                                  | description                              |
|-----------------------------------------|------------------------------------------|
| ArrowWithSinusTarget.BAR_ARROW_FINISHED | elicited after the end of the post phase |

#### SpikeVis Class

Visualise discrete events, such as spikes, with flashing feedback disks. A SpikeVis object can be used as a feedback element for, e.g., the onset and termination of spike trains.

![spikevis](images/spikevis.png)

SpikeVis supports multiple feedback disks and must have as many LSL control channels as feedback disks. The LSL control channels are expected to provide 0/1 values. To set up the control, call the method **controlStateWithLSLStream**. For example:

``` Python
spikes = self.registerObject(GO.SpikeVis(pos_x=0, pos_y=0, number_of_units=3))
spikes.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])
```

_Object Initialisation Parameters:_

| parameter       | value type        | description                                                                                                       |
|-----------------|-------------------|-------------------------------------------------------------------------------------------------------------------|
| pox_x           | double            | horizontal position                                                                                               |
| pos_y           | double            | vertical position                                                                                                 |
| depth           | integer           | depth position                                                                                                    |
| number_of_units | integer           | number of feedback disks; must correspond to the number of LSL control channels                                   |
| size            | double            | size of a feedback disk                                                                                           |
| spacing         | double            | distance between feedback disks                                                                                   |
| flash_duration  | double            | time in seconds a feedback disk flashes (activates) when a “1” is read from the corresponding LSL control channel |
| active_color    | string or 3-tuple | color of the feedback disk when inactive                                                                          |
| inactive_color  | string or 3-tuple | color of the feedback disk when it is active                                                                      |

#### ReachTargets Class

Graphical object to implement target reaching experiments. It displays one or more disk targets which must be reached and held with a 2D cursor. The targets are arranged in a circle around the centre. The cursor is controlled with 2 LSL channels.

![target reach](images/targetreach.png)

To set up the control, call the method **controlStateWithLSLStream**. For example:

``` Python
targetreaching = self.registerObject(GO.ReachTargets(pos_x=0, pos_y=0, number_of_targets=3))
targetreaching.controlStateWithLSLStream(“the-stream”, channels=[0,1])
```

An optional start target can be specified. Such a start target will be placed in the centre and must be reached before the actual target.

The cursor must stay within the correct target area for a certain period (dwell time) to generate a target-reached signal. This target-reached signal can then be used to trigger a script item.

To activate the ReachTargets object at second 10 and set the active (current) target to target 1, create a script item such as:

``` Python
ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)])
```

To end the trial when the target reached signal is generated or a 30s timeout occurs, create a script item such as:

``` Python
ScriptItem(name='trial_end', time=30, time_type='rel', rel_name='trial_start', wait_for_signal=GO.ReachTargets.TARGET_REACHED, actions=[targets.deactivate])
```

_Object Initialisation Parameters:_

| parameter             | value type        | description                                                        |
|-----------------------|-------------------|--------------------------------------------------------------------|
| pox_x                 | double            | horizontal position                                                |
| pos_y                 | double            | vertical position                                                  |
| depth                 | integer           | depth position                                                     |
| radius                | double            | radius of the targets around the center                            |
| number_of_targets     | integer           | number of targets                                                  |
| dwell_time            | double            | dwell or hold time of targets                                      |
| start_target          | bool              | show a start target                                                |
| target_rotation       | double            | rotate targets (in degrees)                                        |
| target_size           | double            | target size                                                        |
| cursor_size           | double            | cursor size                                                        |
| target_active_color   | string or 3-tuple | color of the active (current) target disk                          |
| target_inactive_color | string or 3-tuple | color of the inactivate target disks                               |
| target_reached_color  | string or 3-tuple | color of the target disk when the cursor is within the target area |
| cursor_color          | string or 3-tuple | color of the cursor                                                |

_ScriptItem Actions:_

| method          | parameters          | value types | description                          |
|-----------------|---------------------|-------------|--------------------------------------|
| setActiveTarget | selected_target_idx | integer     | index of the active (current) target |

_ScriptItem Trigger Signals:_

| signal                             | description                              |
|------------------------------------|------------------------------------------|
| ReachTargets.START_TARGET_REACHED  | optional start target has been reached   |
| ReachTargets.TARGET_REACHED        | active (current) target has been reached |

## Auditory Objects

Auditory objects generate sounds. They can be [controllable](paradigm_scripting.md#control-of-auditory-objects) with LSL streams.

To use auditory objects, import the **audio_objects module**:

``` Python
import yaga_modules.audio_objects as AO
```

An auditory object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a beep object:

``` Python
beep = self.registerObject(AO.Beep())
```

The Python classes representing the auditory objects are described in the following.

### Beep Class

Generates a beep sound, e.g., to attract the attention of the subject.

_Object Initialisation Parameters:_

| parameter      | value type | description                                                                                    |
|----------------|------------|------------------------------------------------------------------------------------------------|
| beep_frequency | double     | frequency of the beep in Hz                                                                    |
| beep_amplitude | double     | sound level                                                                                    |
| beep_duration  | double     | duration of a beep in seconds                                                                  |
| beep_channels  | string     | output channels: _"both”_, _“left”_, or _“right”_                                              |
| delay          | double     | - delay the presentation of the beep <br> - use a delay of 0.2s or more to **minimise jitter** |

_ScriptItem Actions:_

| method | parameters | value types | description   |
|--------|------------|-------------|---------------|
| beep   | -          | -           | generate beep |

### SpikeSound Class

Generate a feedback signal for discrete events like spikes. SpikeSound supports multiple event or spike signals which can be associated with a specific sound frequency or output channel. Optionally, the sound frequencies can be dynamically modulated by the instantaneous firing rates. The events are read from an LSL stream which is expected to provide 0/1 values. To set up the LSL control call the method **controlStateWithLSLStream**. For example, to generate sounds for two spike signals using different sound frequencies and output channels:

``` Python
spikes = self.registerObject(AO.SpikeSound(beep_frequencies=\[800, 2000\], beep_channels=\['left', 'right'\]))
spikes.controlStateWithLSLStream(“the-stream”, channels=\[0, 1\])
```

_Object Initialisation Parameters:_

| parameter             | value type      | description                                                                                                                                                                                                 |
|-----------------------|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| beep_frequencies      | list of doubles | - list of frequencies in Hz <br> - must have the same length as number of LSL channels <br> - values must be between 100 Hz and 10 kHz                                                                      |
| beep_channels         | list of strings | - list of output channels (_“both”_, _“left”_, or _“right”_) <br> - must have the same length as number of LSL channels                                                                                     |
| beep_duration         | double          | duration of each spike sound                                                                                                                                                                                |
| downsample            | integer         | downsample factor; generate a spike sound for every x^th^ spike                                                                                                                                             |
| dynamic_frq           | bool            | if _true_, modulate the sound frequency by the instantaneous firing rate                                                                                                                                    |
| dynamic_frq_factor    | integer         | the final sound frequency is the base frequency (from _beep_frequencies_) plus the instantaneous firing rate multiplied by this factor                                                                      |
| dynamic_max_frq       | double          | limit the smoothed instantaneous firing rate to this frequency                                                                                                                                              |
| dynamic_mov_avg       | integer         | - calculate the instantaneous firing rate as the inverse of the interspike interval smoothed with a moving average window of length _dynamic_mov_avg_ <br> - set to _None_ if exponential smoothing is used |
| dynamic_exp_avg_alpha | double          | - calculate the instantaneous firing rate as the inversive of the interspike interval smoothed with exponential smoothing using a smoothing factor of _dynamic_exp_avg_alpha_ <br> - set to _None_ if the moving average is used |

## Special Objects

Special objects implement more complex user interactions than graphical or auditory objects.

### Pacman

This special objects implements a Pacman-style paradigm where study participants should catch as many dots as possible with a Pacman. The dots enter the screen from the right side in a random or pre-programmed trajectory. The vertical position of Pacman is controlled with an LSL stream.

![Pacman](images/pacman.png)

To use Pacman, import the **Pacman class**:

``` Python
from yaga_modules.pacman import Pacman
```

A Pacman object must be created in the initialisation method of the paradigm file and registered to YAGA. Subsequently, one must specify an LSL stream to control the state of Pacman (i.e., its vertical position). For example, to create a Pacman object with a random dot trajectory, setup a control LSL stream with **controlStateWithLSLStream**, and activate Pacman:

``` Python
pacman = self.registerObject(Pacman(item_speed=0.5, item_generator='random', item_generation_frequency=10, frequency=[0.05, 0.15], noise_stddev=3))
pacman.controlStateWithLSLStreams(['the-stream'], channels=[0])
pacman.activate()
```

#### Dot Generators

The Pacman class supports the following dots generators:
- constant: dots are generated at a constant vertical position
- sinus: dots follow a sinusoidal oscillation
- chirp: dots follow a chirp trajectory
- ramp: dots follow a ramp trajectoy (low level -> ramp up -> high level -> ramp down -> low level)
- random: dots follow band-pass or low-pass filtered Gaussian noise limited by tanh

The dot generation frequency and the dots' speed (right to left) is set with the object initialisation parameters _item_generation_frequency_ and _item_speed_, respectively.

The dots enter the screen on the right side, and the time to reach Pacman can be calculated as _T = S/V_. Where _V_ is the dot speed specified with the object initialisation parameter _item_speed_, and _S_ is the distance between the right screen edge (= screen ratio) and the Pacman position (= -1.4) in [Screen Units](paradigm_scripting.md#screen-units). With a 16/9 screen ratio, _S = 16/9 - (-1.4)_ = 3.1777.

#### Negative Feedback

The Pacman class supports negative feedback so that specific behaviorual changes of study participants can be disencouraged. Two types of negative feedback are available:
- position: the x-position of the Pacman changes from a green to a red area with an incresing negative feedback signal
- color: the color of the Pacman changes from yellow to red with an incresing negative feedback signal

Here are examples of the two negative feedback types:

![Negative Feedback Position](images/pacman_neg_feedback_position.png) ![Negative Feedback Color](images/pacman_neg_feedback_color.png)


If negative feedback is used, the state of the Pacman object is controlled with two channels from an LSL Stream. The first channel controls the vertical Pacman position, the second channel is considered as the negative feedback signal. Specify the two channels with **controlStateWithLSLStream**, for example:
``` Python
pacman.controlStateWithLSLStreams(['the-stream'], channels=[0, 1])
```

#### LSL Output Streams

The Pacman object creates a 4-channel LSL output stream with name *pacman* and source ID *pacman_state*. The LSL output stream contains the following state variables:
- vertical position of Pacman
- negative feedback signal
- vertical position of the dot closest to Pacman on its right side
- highscore counter

The LSL output stream sends data synchronized with the screen refresh rate. 

**Important note:** the LSL output stream is only populated with state values while the Pacman object is activated.


#### Object Initialisation Parameters

| parameter                 | value type                  | description                                                                                                                                                         |
|---------------------------|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| pox_x                     | double                      | horizontal position of the special object                                                                                                                           |
| pos_y                     | double                      | vertical position of the special object                                                                                                                             |
| depth                     | integer                     | depth position of the special object                                                                                                                                |
| item_generator            | string                      | dot trajectory generator: "constant", "sinus", "chirp", "ramp", or "random"                                                                                         |
| item_speed                | double                      | speeds of dots (right to left movement) in screen units/second ([Screen Units](paradigm_scripting.md#screen-units))                                                 |
| item_generation_frequency | double                      | number of dots generated per second                                                                                                                                 |
| amplitude                 | double                      | in [Screen Units](paradigm_scripting.md#screen-units) <br> - constant generator: y-position of the dots <br> - sinus/chirp generator: amplitude of the oscillation <br> - random generator: after limiting the band-pass or low-pass filtered Gaussian noise with tanh, the limited noise is multiplied with this amplitude factor |
| frequency                 | double or list of 2 doubles | in Hz <br> - sinus generator: frequency of the sinusoidal trajectory <br> - chirp generator: start and end frequency of the sinusoidal trajectory <br> - random generator: cutoff frequency (frequencies) of the low-pass (band-pass) filter applied to the generated Gaussian noise |
| phase_duration            | double or list of 5 doubles | in seconds <br> - chirp generator: time to progress from the start to the end frequency <br> - ramp generator: durations of low/ramp-up/high/ramp-down/low phases   |
| phase_value               | list of 2 doubles           | for ramp generator: y-positions during low and high phases                                                                                                          |
| noise_stddev              | double                      | for random generator: std. dev. of the generated Gaussian noise                                                                                                    |
| neg_feedback_type         | string                      | sets the type of negative feedback: None, "pos", or "color"; two control channels must be specified with **controlStateWithLSLStream** if negative feedback is used |
| highscore                 | bool                        | shows the number of collected dots                                                                                                                                  |
| fps                       | integer                     | this value is used as the sampling rate in the meta-data of the output LSL stream; set *fps* to the screen refresh rate if it is different than 60 Hz               |

#### ScriptItem Actions

| method        | parameters | value types | description                                                                |
|---------------|------------|-------------|----------------------------------------------------------------------------|
| activate      | -          | -           | show Pacman object on screen and start populating the output LSL stream    |
| deactivate    | -          | -           | hide Pacman object and stop populating the output LSL stream               |
| start         | -          | -           | start the dot generator and reset highscore counter                        |
| stop          | -          | -           | stop the dot generator                                                     |

#### ScriptItem Trigger Signals:

| signal                      | description                                                             |
|-----------------------------|-------------------------------------------------------------------------|
| Pacman.GENERATION_FINISHED  | the dot generator has finished (only applicable for the ramp generator) |


#### Pacman Demo Script

The paradigm file _demo_pacman.py_ implements a Pacman object with a random dot generator. Additionaly, a background picture is configured. The Pacman can be controlled with the _mousecontroller.py_ script in the _tools_ folder. This script captures the mouse cursor when it is in the application window and sends is relative coordinates as a 2-channel LSL stream with the name _MouseControllerStream_. This stream is specified as the state control LSL stream in the paradigm file.  _mousecontroller.py_ must be started before YAGA.

![Pacman](images/pacman_bg.png)

The full source code of the demo paradigm file:

``` Python
{!paradigms/pacman_demo.py!}
```

## Online Control of Objects with LSL streams

The parameters of graphical and auditory objects can be controlled with LSL streams. For that purpose, LSL streams can be read directly or processed online (scaling, filtering, etc.). The parameter updates are synchronous to the screen refresh rate.

### Control of Graphical Objects

The position, scale, colour or state of graphical objects can be controlled by one or more LSL streams. For that, call the respective control method listed below.

*Methods for controlling a property with a single LSL stream:*

| method                    | parameters                                                                           | value types                                          | description                                                                      |
|---------------------------|--------------------------------------------------------------------------------------|------------------------------------------------------|----------------------------------------------------------------------------------|
| controlPosWithLSLStream   | lsl_stream_name, channels, aggregation_mode                                          | string, list of integers, string                     | control the x/y position of an object with two channels from a single LSL stream |
| controlScaleWithLSLStream | lsl_stream_name, channels, aggregation_mode                                          | string, list of integers, string                     | control the x/y size of an object with two channels from a single LSL stream     |
| controlColorWithLSLStream | lsl_stream_name, channel, aggregation_mode, <br> neg_color, pos_color, neutral_color | string, integer, string, <br> string, string, string | - interpolate between colors using one channel from a single LSL stream: <br> &nbsp;&nbsp;&nbsp;&nbsp; when the value of the LSL channel is in the interval \[-1, 0): interpolate between the negative and neutral color <br> &nbsp;&nbsp;&nbsp;&nbsp; when the value of the LSL channel is in the interval \[0, 1\]: interpolate between the neutral and positive color <br> - colors must be specified by their name (_string_) |
| controlStateWithLSLStream | lsl_stream_name, channels, aggregation_mode                                          | string, list of integers, string                     | state updates are specific to the [graphical object](paradigm_scripting.md#supported-graphical-objects) |

-   the _channels_ parameter of **controlPosWithLSLStream** and **controlScaleWithLSLStream** must be a list comprising two channel indices
-   the _channel_ parameter of **controlColorWithLSLStream** must be a channel index
-   the _channels_ parameter of **controlStateWithLSLStream** must be a list with one or more channel indices (the number of channels depends on the actual graphical object)
-   for an explanation of the _aggregation_mode_ parameter see [Aggregation Mode](paradigm_scripting.md#aggregation-mode)
-   **note that channel indexing starts with a 0 in Python**

*Methods for controlling a property with multiple LSL stream:*

| method                     | parameters                                   | value types                               | description                                                                                                                   |
|----------------------------|----------------------------------------------|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| controlPosWithLSLStreams   | lsl_stream_names, channels, aggregation_mode | list of strings, list of integers, string | control the x/y position of an object with two channels from two separate LSL streams                                         |
| controlScaleWithLSLStreams | lsl_stream_names, channels, aggregation_mode | list of strings, list of integers, string | controls the x/y size of an object with two channels from two separate LSL streams                                            |
| controlStateWithLSLStreams | lsl_stream_names, channels, aggregation_mode | list of strings, list of integers, string | currently only supported by [Bar Class](paradigm_scripting.md#bar-class) and [Arrow Class](paradigm_scripting.md#arrow-class) |

### Control of Auditory Objects

Auditory objects support the following methods to set up LSL control.

*Methods for controlling a property with one or more LSL stream:*

| method                | parameters                               | value types                              | description                                                                            |
|-----------------------|------------------------------------------|------------------------------------------|----------------------------------------------------------------------------------------|
| controlWithLSLStream  | stream name, channels, aggregation_mode  | string, list of integers, string         | currently only supported by [SpikeSound Class](paradigm_scripting.md#spikesound-class) |
| controlWithLSLStreams | stream names, channels, aggregation_mode | list of string, list of integers, string | not yet supported by any auditory object                                               |

### Aggregation Mode

The LSL streams used to control the parameters of graphical or auditory objects are read and processed just before a screen refresh. All updates are therefore synchronised with the screen refresh rate, which is often 60 Hz.

- when the sampling frequency of an LSL stream is **lower** than the screen refresh rate, the LSL stream is **upsampled** to the screen frequency using a _sample & hold strategy_
- when the sampling frequency of an LSL stream is **higher** than the screen frequency, the LSL stream is **downsampled** strategy specified by _aggregation_mode_ is used

The following sample aggregation strategies are supported:

| aggregation mode value | description                                               |
|------------------------|-----------------------------------------------------------|
| last (default)         | the most recent LSL sample is used, the rest is discarded |
| sum                    | the LSL samples since the last read-out are summed up     |
| mean                   | the LSL samples since the last read-out are averaged      |

### Signal Processing

LSL streams can be processed when used to control parameters of graphical or auditory objects. YAGA signal processing is applied to the _original_ LSL stream, i.e., before any re-sampling to the screen refresh rate (see [Aggregation Mode](paradigm_scripting.md#aggregation-mode)).

To use signal processing on LSL streams, import the **signal_processing module**:

``` Python
import yaga_modules.signal_processing as SP
```

Signal processing objects can be added to the signal processing pipeline by calling the method **addSignalProcessingToLSLStream**. In the following example, a feedback bar is set to be controlled by an LSL stream and the LSL stream is filtered with a Butterworth low-pass filter and scaled:

``` Python
bar = self.registerObject(GO.Bar())
bar.controlStateWithLSLStream('the-stream', channels=[10])

butter = SP.ButterFilter(4, 5)
scaler = SP.Scaler(scale=2)

bar.addSignalProcessingToLSLStream(butter, channels=[10])
bar.addSignalProcessingToLSLStream(scaler, channels=[10])
```

The first parameter of **addSignalProcessingToLSLStream** is the signal processing object. The second parameter is the channel list. The number of supported channels depends on the concrete signal processing object.

**Important note:** Make sure that signal processing objects which have a state (e.g., ButterFilter) exist only in one signal processing pipeline. If you need the same signal processing method applied to another LSL stream, create a new signal processing object.

The following signal processing objects are supported by YAGA.

#### Constant

Set channels to a constant value.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter | value type | description                    |
|-----------|------------|--------------------------------|
| value     | double     | set signals to the given value |

#### CopyChannel

Copy values from one channel to another channel.

Number of supported channels: two or more

Operates channel-wise: no

Stateful: no

_Object Initialisation Parameters:_

| parameter   | value type | description                      |
|-------------|------------|----------------------------------|
| channel_in  | integer    | index of the source channel      |
| channel_out | integer    | index of the destination channel |

#### ButterFilter

Filters stream with a Butterworth filter.

Number of supported channels: one or more

Operates channel-wise: Yes

Stateful: Yes

_Object Initialisation Parameters:_

| parameter   | value type                | description                                                                                                                                               |
|-------------|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| order       | integer                   | order of the filter                                                                                                                                       |
| cutoff_frqs | double or list of doubles | critical frequency or frequencies: <br> &nbsp;&nbsp;&nbsp;&nbsp; - low/highpass: a scalar <br> &nbsp;&nbsp;&nbsp;&nbsp; - bandpass/stop: a 2-element list |
| filter_type | string                    | filter type, possible values: _lowpass_, _highpass_, _bandpass_, _bandstop_                                                                               |

#### MovAvg

Moving average filter.

Number of supported channels: one or more

Operates channel-wise: Yes

Stateful: Yes

_Object Initialisation Parameters:_

| parameter     | value type | description                            |
|---------------|------------|----------------------------------------|
| window_length | integer    | length of the moving window in seconds |


#### Angle

Calculates the angle in radians between the x-axis and the point given by (x,y). The first channel represents the x-coordinate, and the second channel represents the y-coordinate.

Number of supported channels: two

Operates channel-wise: no

Stateful: no

#### Integrate

Integration over samples.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: yes

_Object Initialisation Parameters:_

| parameter | value type | description                                     |
|-----------|------------|-------------------------------------------------|
| factor    | double     | multiply samples by a factor before integration |

#### Diff

Calculates the difference between two consecutive samples.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: yes

#### Sum

Calculates the sum over channels.

Number of supported channels: two or more

Operates channel-wise: no

Stateful: no

#### Mean

Calculates the average over channels.

Number of supported channels: two or more

Operates channel-wise: no

Stateful: no

#### StdDev

Calculates the standard deviation over channels.

Number of supported channels: two or more

Operates channel-wise: no

Stateful: no

#### Scaler

Multiplies channels by a scaling factor and adds offsets before and after scaling.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter   | value type | description                     |
|-------------|------------|---------------------------------|
| scale       | double     | scale samples by this factor    |
| pre_offset  | double     | add _pre_offset_ before scaling |
| post_offset | double     | add _post_offset_ after scaling |

#### LinearMap

Linearly maps signals from the interval [_in_val1_, _in_val2_] to the interval [_out_val1_, _out_val2_].

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter | value type |
|-----------|------------|
| in_val1   | double     |
| in_val2   | double     |
| out_val1  | double     |
| out_val2  | double     |

#### Limit

Limit signals to minimum and maximum values.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter | value type | description   |
|-----------|------------|---------------|
| min_val   | double     | minimum value |
| max_val   | double     | maximum value |

#### Abs

Calculates the absolute value.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

#### Power

Raises signals to the given power.

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter | value type | description      |
|-----------|------------|------------------|
| exponent  | double     | exponent (power) |

#### EuclidNorm

Calculate the Euclidean norm over channels.

Number of supported channels: one or more

Operates channel-wise: no

Stateful: no

#### MaxEuclidNormalizationXDF

Normalise channels by the maximum Euclidean norm found from the data channels in the specified XDF file (e.g., force normalisation).

Find maximum:

1.  load the XDF file
2.  apply a median window filter to the selected channels of the data stream
3.  subtract a common or channel-specific offset
4.  calculate the 2-norm over all selected channels
5.  find the maximum norm value over all trials

Online processing:

1.  subtract offset from signals
2.  divide by the found maximum norm

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: no

_Object Initialisation Parameters:_

| parameter            | value type               | description                                                                                                |
|----------------------|--------------------------|------------------------------------------------------------------------------------------------------------|
| xdf_file             | string                   | XDF file to load                                                                                           |
| data_stream_name     | string                   | name of data stream over which the Euclidean norm is calculated (e.g., 2D force data)                      |
| marker_stream_name   | string                   | name of the event stream                                                                                   |
| start_marker         | string                   | name of a trial start event                                                                                |
| data_stream_channels | list of integers         | channel indices of the data stream over which the Euclidean norm is calculated (if None, use all channels) |
| offset               | double or list of double | - subtract an offset value before calculating the Euclidean norm <br> - to specify channel-specific offsets, specify offsets as a list with one offset value per channel <br> - set to _None_ to subtract the minimum of each channel |
| filter_window_length | integer                  | filter data stream with a median filter using the specified window size in samples (must be odd)           |

#### MaxAvgPowerNormalizationXDF

Normalise channels by the maximum power found from the data channels in the specified XDF file (e.g., EMG power normalisation).

Find maximum:

1.  load the XDF file
2.  apply a Butterworth bandpass filter to the selected channels of the data stream (pre-filter)
3.  calculate the signal power of all selected channels
4.  apply a moving average filter (post-filter)
5.  calculate the median signal power over all selected channels
6.  find the 90% percentile of the power over all trials

Online processing:

1.  apply the pre-filter (bandpass)
2.  calculate the signal power
3.  apply the post-filter (moving average)
4.  calculate the median over channels
5.  divide signals by found 90% percentile of the power

Number of supported channels: one or more

Operates channel-wise: yes

Stateful: yes

_Object Initialisation Parameters:_

| parameter             | value type       | description                                                                                                       |
|-----------------------|------------------|-------------------------------------------------------------------------------------------------------------------|
| xdf_file              | string           | XDF file to load                                                                                                  |
| data_stream_name      | string           | name of data stream over which the Euclidean norm is calculated (e.g., 2D force data)                             |
| marker_stream_name    | string           | name of the event stream                                                                                          |
| start_marker          | string           | name of a trial start event                                                                                       |
| end_marker            | string           | name of a trial end event                                                                                         |
| data_stream_channels  | list of integers | channel indices of the data stream over which the Euclidean norm is calculated (if _None_, use all channels)      |
| prefilter_order       |                  | Butterworth bandpass filter order                                                                                 |
| prefilter_cutoff_frqs |                  | Butterworth bandpass cutoff frequencies                                                                           |
| postfilter_win_length |                  | - apply a moving average filter with the specified windows length in samples <br> - set to 1 to deactivate filter |

#### FlappyBirdController

Implements a Flappy Bird style 2D control with discrete events like spikes. As input, a 1D signal comprising 0/1 values is expected (e.g., spiking activity). The generated output is a 2D position signal, which can be used to control the position of other graphical objects.

The control works as follows:

- an input activity increases the position on the currently controlled axis
- a short pause in the input activity switches the control between the x and y axis
- the x and y positions decrease at a constant velocity

Note: The signal processing object expects 2 channels, but only the activity in the first channel is evaluated. The channel values will be replaced by the calculated x/y position.

Number of supported channels: two

Operates channel-wise: no

Stateful: yes

_Object Initialisation Parameters:_

| parameter       | value type | description                                                                                                                                   |
|----------------------|-------------|--------------------------------------|
| pos_increment   | double     | each discrete event (spike) increases the position on the currently controlled axis by this value                                             |
| negative_vel    | double     | decrease the position on both axes by this velocity; however, recent spiking activity prevents the currently controlled axis from this change |
| switch_interval | double     | minimum pause interval to switch between x and y axis                                                                                         |
| x_max           | double     | limit x position to this value                                                                                                                |
| y_max           | double     | limit y position to this value                                                                                                                |
