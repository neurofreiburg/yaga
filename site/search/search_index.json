{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"YAGA Documentation \u00b6 YAGA is a presentation and paradigm scripting program for research experiments focusing on behavioural and neuroscience experiments. Features: presentation of visual and auditory stimuli scripting of the paradigm sequence integration with the Lab Steaming Layer (LSL) system online control of graphical and sound objects with LSL signal streams online processing of LSL signal streams simple but extensible signal processing capabilities multiplatform capability (Windows/Mac/Linux) (Linux support is experimental) YAGA is written in Python and is based on the Panda3D game engine. It can implement various experimental paradigms with a so-called paradigm file . The paradigm file specifies the sequence of screen instructions, cues or stimuli. Optionally, the paradigm file can configure the control of graphical and auditory objects with Lab Streaming Layer (LSL) streams. For example, the x/y position of a cursor in target reaching experiment could be controlled with a two-channel LSL stream. YAGA can read LSL streams directly from amplifiers or intermediate signal processing applications. YAGA also allows internal signal processing of LSL streams. Processed LSL streams can be relayed as LSL output streams. Moreover, YAGA outputs the paradigm sequence as LSL event marker to allow later time-locking to events like stimuli presentation. All input streams, processed LSL streams, and the paradigm sequence can then be recorded while the LSL system handles time synchronisation between the streams. Together with LSL, YAGA allows the conducting of scientific experiments or the implementation of online control systems.","title":"Home"},{"location":"#yaga-documentation","text":"YAGA is a presentation and paradigm scripting program for research experiments focusing on behavioural and neuroscience experiments. Features: presentation of visual and auditory stimuli scripting of the paradigm sequence integration with the Lab Steaming Layer (LSL) system online control of graphical and sound objects with LSL signal streams online processing of LSL signal streams simple but extensible signal processing capabilities multiplatform capability (Windows/Mac/Linux) (Linux support is experimental) YAGA is written in Python and is based on the Panda3D game engine. It can implement various experimental paradigms with a so-called paradigm file . The paradigm file specifies the sequence of screen instructions, cues or stimuli. Optionally, the paradigm file can configure the control of graphical and auditory objects with Lab Streaming Layer (LSL) streams. For example, the x/y position of a cursor in target reaching experiment could be controlled with a two-channel LSL stream. YAGA can read LSL streams directly from amplifiers or intermediate signal processing applications. YAGA also allows internal signal processing of LSL streams. Processed LSL streams can be relayed as LSL output streams. Moreover, YAGA outputs the paradigm sequence as LSL event marker to allow later time-locking to events like stimuli presentation. All input streams, processed LSL streams, and the paradigm sequence can then be recorded while the LSL system handles time synchronisation between the streams. Together with LSL, YAGA allows the conducting of scientific experiments or the implementation of online control systems.","title":"YAGA Documentation"},{"location":"installation/","text":"Installation \u00b6 YAGA supports Linux, Mac or Windows (tested with macOS 13, Windows 10; Linux support is experimental). YAGA requires Python version >= 3.9. To install Python on Windows, you can use the Anaconda Individual Edition from ( https://www.anaconda.com ). The following Python packages are required: numpy scipy panda3d pmw pylsl pyxdf rtmixer nidaqmx You can install the packages with the command conda . When a package is not available via conda , you can use the package installer pip (which can be installed with conda ). If you require sound output, you need to install PortAudio . In Linux, you can use your local package manager to install PortAudio ; on Mac, you can use Homebrew . In Windows, PortAudio is included in the sounddevice library, which is a dependency of rtmixer . YAGA itself does not require any particular installation step. Simply copy all files and directories to a destination of your choice.","title":"Installation"},{"location":"installation/#installation","text":"YAGA supports Linux, Mac or Windows (tested with macOS 13, Windows 10; Linux support is experimental). YAGA requires Python version >= 3.9. To install Python on Windows, you can use the Anaconda Individual Edition from ( https://www.anaconda.com ). The following Python packages are required: numpy scipy panda3d pmw pylsl pyxdf rtmixer nidaqmx You can install the packages with the command conda . When a package is not available via conda , you can use the package installer pip (which can be installed with conda ). If you require sound output, you need to install PortAudio . In Linux, you can use your local package manager to install PortAudio ; on Mac, you can use Homebrew . In Windows, PortAudio is included in the sounddevice library, which is a dependency of rtmixer . YAGA itself does not require any particular installation step. Simply copy all files and directories to a destination of your choice.","title":"Installation"},{"location":"integration_with_lsl/","text":"Integration with Lab Streaming Layer (LSL) \u00b6 LSL Input Streams \u00b6 YAGA can read LSL streams and use them to control graphical and auditory objects. You can set up the LSL control with the methods control[pos|scale|color|state]WithLSLStream and controlWithLSLStream for graphical objects and auditory objects, respectively. If supported by the objects, they can also be controlled by multiple LSL streams by using the methods control[\u2026]WithLSLStream s . See Control of Graphical Objects and Control of Auditory Objects for details. Signal processing of the LSL streams is also possible. YAGA is agnostic to the signal source as long as the LSL signals are streamed with a regular sampling rate. LSL streams can also be used as triggers for script items . In that case, the LSL streams must have an irregular sampling rate (aka event marker streams). LSL Output Streams \u00b6 If a script item has a name set, an LSL event marker is generated when the script item is triggered. YAGA creates the LSL stream yaga for this purpose, which contains the event markers. The marker itself is the script item name. yaga is an LSL stream with an irregular sampling rate and a string data format. This allows YAGA trigger events to be recorded along with LSL data streams. LSL input streams can also be relayed to LSL output streams. This is useful if graphical or auditory objects are controlled with processed LSL streams, and one wants to record the processed streams. To set up a stream relay use the method relayLSLSignals on the respective graphical or auditory object. For example: feedback = self.registerObject(GO.Ball()) feedback.controlPosWithLSLStream('streamA', channels=[0, 1]) feedback.relayLSLSignals(lsl_in_signals=['streamA'], channels=[[0, 1]], lsl_out_signal='yaga_streamA') Set the parameter lsl_in_signals to a list of LSL streams which should be relayed for the associated representation object. Set channels to a list of channel indices for each relayed LSL stream (i.e., a list of lists). Set the LSL output stream name with lsl_out_signal . All relayed LSL streams are collected in one LSL output stream. 3 rd party LSL Software \u00b6 Supported Devices \u00b6 A large number of devices like bio-amplifiers, motion capture systems, eye trackers, or input devices are supported by LSL. See https://labstreaminglayer.readthedocs.io/info/supported_devices.html for a list of devices. Data Recording \u00b6 The LSL streams can be saved to the hard disk in the XDF format using LabRecorder . The data recording can be manually started and stopped in LabRecorder. Lab Recorder also supports remote control via the UDP port. YAGA supports Lab Recorder's remote control interface and can automatically set the XDF file name and path, and start and stop a recording. To enable remote control in your paradigm file, you need to: specify the root directory of the XDF files and a task name as class variables in your Paradigm class ( root_dir , task_name ) set the parameter lsl_recorder_remote_control to True when you initialise the Paradigm\u2019s parent class optionally, you can specify the hostname and port of the Lab Recorder instance when you initialise the Paradigm\u2019s parent class ( lsl_recorder_host , lsl_recorder_port ) For example: class Paradigm(ParadigmBase): root_dir = Path.home() / Path('studies') / Path('StudyA') task_name = 'condition1' def __init__(self, paradigm_variables): super().__init__(paradigm_variables, lsl_recorder_remote_control=True) When you start YAGA, you need to additionally specify the subject code, session number and run number as this information is used to build the XDF file name and send to Lab Recorder: python yaga.py --paradigm YOURPARADIGM --subject ABC --session 1 --run 3 In the above example, YAGA configures Lab Recorder to save all available LSL streams to the file \\studies\\StudyA\\ABC_S001\\task_condition1_003.xdf in your home directory. Online Data Visualisation \u00b6 The BrainVision LSL Viewer, developed by Brain Products GmbH, is a handy tool for inspecting and monitoring LSL streams and checking the signal quality. See the websites: https://pressrelease.brainproducts.com/lsl-viewer https://www.brainproducts.com/downloads/more-software/#utilities Offline Data Visualization \u00b6 SigViewer allows inspecting XDF files. Loading Data in Matlab \u00b6 Matlab Importer \u00b6 To load the XDF data files into Matlab use Matlab Importer . Here is some example code to load an XDF file in Matlab: xdf_data = load_xdf(\u2018data_file_1.xdf\u2019); get_stream_idx = @(stream_name, xdf) find(arrayfun(@(stream) strcmp(stream{1}.info.name, stream_name), xdf)); % helper function to get the stream index by the stream name % get the YAGA events yaga_idx = get_stream_idx('yaga', xdf_data); yaga_events = xdf_data{yaga_idx}.time_series; yaga_timestamps = xdf_data{yaga_idx}.time_stamps; % get the data stream datastream_idx = get_stream_idx('the-stream', xdf_data); stream_fs = str2double(xdf_data{datastream_idx}.info.nominal_srate); stream_data = xdf_data{datastream_idx}.time_series'; % \\[samples x channels\\] stream_timestamps = xdf_data{datastream_idx}.time_stamps; EEGlab \u00b6 One can use EEGlab to open XDF files and conduct extensive analyses. You must first install one of the following plugins via File -> Manage EEGLAB extensions : xdfimport Mobilab Note that only the Mobilab plugin allows to resample multiple streams to a common sampling rate.","title":"Integration with Lab Streaming Layer (LSL)"},{"location":"integration_with_lsl/#integration-with-lab-streaming-layer-lsl","text":"","title":"Integration with Lab Streaming Layer (LSL)"},{"location":"integration_with_lsl/#lsl-input-streams","text":"YAGA can read LSL streams and use them to control graphical and auditory objects. You can set up the LSL control with the methods control[pos|scale|color|state]WithLSLStream and controlWithLSLStream for graphical objects and auditory objects, respectively. If supported by the objects, they can also be controlled by multiple LSL streams by using the methods control[\u2026]WithLSLStream s . See Control of Graphical Objects and Control of Auditory Objects for details. Signal processing of the LSL streams is also possible. YAGA is agnostic to the signal source as long as the LSL signals are streamed with a regular sampling rate. LSL streams can also be used as triggers for script items . In that case, the LSL streams must have an irregular sampling rate (aka event marker streams).","title":"LSL Input Streams"},{"location":"integration_with_lsl/#lsl-output-streams","text":"If a script item has a name set, an LSL event marker is generated when the script item is triggered. YAGA creates the LSL stream yaga for this purpose, which contains the event markers. The marker itself is the script item name. yaga is an LSL stream with an irregular sampling rate and a string data format. This allows YAGA trigger events to be recorded along with LSL data streams. LSL input streams can also be relayed to LSL output streams. This is useful if graphical or auditory objects are controlled with processed LSL streams, and one wants to record the processed streams. To set up a stream relay use the method relayLSLSignals on the respective graphical or auditory object. For example: feedback = self.registerObject(GO.Ball()) feedback.controlPosWithLSLStream('streamA', channels=[0, 1]) feedback.relayLSLSignals(lsl_in_signals=['streamA'], channels=[[0, 1]], lsl_out_signal='yaga_streamA') Set the parameter lsl_in_signals to a list of LSL streams which should be relayed for the associated representation object. Set channels to a list of channel indices for each relayed LSL stream (i.e., a list of lists). Set the LSL output stream name with lsl_out_signal . All relayed LSL streams are collected in one LSL output stream.","title":"LSL Output Streams"},{"location":"integration_with_lsl/#3rd-party-lsl-software","text":"","title":"3rd party LSL Software"},{"location":"integration_with_lsl/#supported-devices","text":"A large number of devices like bio-amplifiers, motion capture systems, eye trackers, or input devices are supported by LSL. See https://labstreaminglayer.readthedocs.io/info/supported_devices.html for a list of devices.","title":"Supported Devices"},{"location":"integration_with_lsl/#data-recording","text":"The LSL streams can be saved to the hard disk in the XDF format using LabRecorder . The data recording can be manually started and stopped in LabRecorder. Lab Recorder also supports remote control via the UDP port. YAGA supports Lab Recorder's remote control interface and can automatically set the XDF file name and path, and start and stop a recording. To enable remote control in your paradigm file, you need to: specify the root directory of the XDF files and a task name as class variables in your Paradigm class ( root_dir , task_name ) set the parameter lsl_recorder_remote_control to True when you initialise the Paradigm\u2019s parent class optionally, you can specify the hostname and port of the Lab Recorder instance when you initialise the Paradigm\u2019s parent class ( lsl_recorder_host , lsl_recorder_port ) For example: class Paradigm(ParadigmBase): root_dir = Path.home() / Path('studies') / Path('StudyA') task_name = 'condition1' def __init__(self, paradigm_variables): super().__init__(paradigm_variables, lsl_recorder_remote_control=True) When you start YAGA, you need to additionally specify the subject code, session number and run number as this information is used to build the XDF file name and send to Lab Recorder: python yaga.py --paradigm YOURPARADIGM --subject ABC --session 1 --run 3 In the above example, YAGA configures Lab Recorder to save all available LSL streams to the file \\studies\\StudyA\\ABC_S001\\task_condition1_003.xdf in your home directory.","title":"Data Recording"},{"location":"integration_with_lsl/#online-data-visualisation","text":"The BrainVision LSL Viewer, developed by Brain Products GmbH, is a handy tool for inspecting and monitoring LSL streams and checking the signal quality. See the websites: https://pressrelease.brainproducts.com/lsl-viewer https://www.brainproducts.com/downloads/more-software/#utilities","title":"Online Data Visualisation"},{"location":"integration_with_lsl/#offline-data-visualization","text":"SigViewer allows inspecting XDF files.","title":"Offline Data Visualization"},{"location":"integration_with_lsl/#loading-data-in-matlab","text":"","title":"Loading Data in Matlab"},{"location":"integration_with_lsl/#matlab-importer","text":"To load the XDF data files into Matlab use Matlab Importer . Here is some example code to load an XDF file in Matlab: xdf_data = load_xdf(\u2018data_file_1.xdf\u2019); get_stream_idx = @(stream_name, xdf) find(arrayfun(@(stream) strcmp(stream{1}.info.name, stream_name), xdf)); % helper function to get the stream index by the stream name % get the YAGA events yaga_idx = get_stream_idx('yaga', xdf_data); yaga_events = xdf_data{yaga_idx}.time_series; yaga_timestamps = xdf_data{yaga_idx}.time_stamps; % get the data stream datastream_idx = get_stream_idx('the-stream', xdf_data); stream_fs = str2double(xdf_data{datastream_idx}.info.nominal_srate); stream_data = xdf_data{datastream_idx}.time_series'; % \\[samples x channels\\] stream_timestamps = xdf_data{datastream_idx}.time_stamps;","title":"Matlab Importer"},{"location":"integration_with_lsl/#eeglab","text":"One can use EEGlab to open XDF files and conduct extensive analyses. You must first install one of the following plugins via File -> Manage EEGLAB extensions : xdfimport Mobilab Note that only the Mobilab plugin allows to resample multiple streams to a common sampling rate.","title":"EEGlab"},{"location":"license/","text":"GNU GENERAL PUBLIC LICENSE \u00b6 Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble \u00b6 The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS \u00b6 0. Definitions. \u00b6 \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. \u00b6 The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. \u00b6 All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. \u00b6 No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. \u00b6 You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. \u00b6 You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. \u00b6 You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \u00b6 \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. \u00b6 You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. \u00b6 You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. \u00b6 Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. \u00b6 A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. \u00b6 If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. \u00b6 Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. \u00b6 The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. \u00b6 THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. \u00b6 IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. \u00b6 If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS","title":"License"},{"location":"license/#gnu-general-public-license","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.","title":"GNU GENERAL PUBLIC LICENSE"},{"location":"license/#preamble","text":"The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow.","title":"Preamble"},{"location":"license/#terms-and-conditions","text":"","title":"TERMS AND CONDITIONS"},{"location":"license/#0-definitions","text":"\"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.","title":"0. Definitions."},{"location":"license/#1-source-code","text":"The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work.","title":"1. Source Code."},{"location":"license/#2-basic-permissions","text":"All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.","title":"2. Basic Permissions."},{"location":"license/#3-protecting-users-legal-rights-from-anti-circumvention-law","text":"No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law."},{"location":"license/#4-conveying-verbatim-copies","text":"You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.","title":"4. Conveying Verbatim Copies."},{"location":"license/#5-conveying-modified-source-versions","text":"You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.","title":"5. Conveying Modified Source Versions."},{"location":"license/#6-conveying-non-source-forms","text":"You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.","title":"6. Conveying Non-Source Forms."},{"location":"license/#7-additional-terms","text":"\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.","title":"7. Additional Terms."},{"location":"license/#8-termination","text":"You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.","title":"8. Termination."},{"location":"license/#9-acceptance-not-required-for-having-copies","text":"You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.","title":"9. Acceptance Not Required for Having Copies."},{"location":"license/#10-automatic-licensing-of-downstream-recipients","text":"Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.","title":"10. Automatic Licensing of Downstream Recipients."},{"location":"license/#11-patents","text":"A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.","title":"11. Patents."},{"location":"license/#12-no-surrender-of-others-freedom","text":"If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.","title":"12. No Surrender of Others' Freedom."},{"location":"license/#13-use-with-the-gnu-affero-general-public-license","text":"Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.","title":"13. Use with the GNU Affero General Public License."},{"location":"license/#14-revised-versions-of-this-license","text":"The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.","title":"14. Revised Versions of this License."},{"location":"license/#15-disclaimer-of-warranty","text":"THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.","title":"15. Disclaimer of Warranty."},{"location":"license/#16-limitation-of-liability","text":"IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.","title":"16. Limitation of Liability."},{"location":"license/#17-interpretation-of-sections-15-and-16","text":"If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS","title":"17. Interpretation of Sections 15 and 16."},{"location":"paradigm_scripting/","text":"Paradigm Scripting \u00b6 Introduction \u00b6 The paradigm is programmed via a so-called paradigm file . A paradigm file contains regular Python code and must define the Paradigm class , which must derive from the ParadigmBase parent class . Its code is automatically loaded when YAGA starts. A typical skeleton looks like this: from yaga_modules.paradigm_base import ParadigmBase import yaga_modules.graphic_objects as GO import yaga_modules.audio_objects as AO import yaga_modules.signal_processing as SP class Paradigm(ParadigmBase): def __init__(self, paradigm_variables): super().__init__(paradigm_variables) [\u2026] Creation of a Presentation Objects \u00b6 YAGA supports the timed presentation of several graphical or auditory objects, e.g., text, circles, or beep tones. A presentation object needs to be created within the __init__ constructor of the Paradigm class and registered to YAGA. A simple text object can be created as: info_text = self.registerObject(GO.Text('prepare for task')) In this example, GO.Text refers to the Text class defined in the graphic_objects module (GO). The call of registerObject is obligatory and registers the object to YAGA. Timing of Presentation Objects \u00b6 Once an object has been created and registered, state changes of the object can be scripted, i.e., timed. For that purpose, the ParadigmBase parent class provides the instance variable script . script must be a list of ScriptItem objects. A ScripItem object specifies: a list of actions to execute when triggered the trigger (time, signal or LSL event marker) an informative name which is sent as an LSL event marker when the ScriptItem is triggered Demo Paradigm \u00b6 The paradigm demo.py implements a simple paradigm where study participants execute a task after a Go cue. The paradigm shows an information text and a traffic light on the screen. The traffic light represents the Go cue, after which a countdown starts. While the countdown is running, the study participants would be asked to execute a specific task. The demo paradigm file shows the creation of the text, traffic light images, and countdown objects. A trial comprises the following script items: \u201ctrial_start\u201d , \u201cinfo_text\u201d , \u201ctraffic_ligh_red\u201d , \u201ctraffic_ligh_yellow\u201d , \u201ctraffic_ligh_green\u201d , \u201ccountdown\u201d , \u201ctrial_end\u201d , which are sequentially executed. Each script item specifies optionally the actions to execute when the script item is triggered. Note that the actions must be specified as objects instead of as actual method calls (i.e., no parentheses). The script list contains in total 5 (TODO) trial sequences, which are built using a for loop. The demo paradigm file demonstrates 3 possible trigger types: absolute time , relative time , and signal-based . An absolute time trigger is used by the first \u201ctrial_start\u201d script item, which is triggered 5s after the program start. However, the subsequent \u201ctrial_start\u201d script items are triggered relative to the previous \u201ctrial_end\u201d script item within a random time interval (5-10s). A relative time trigger can be requested by setting the time_type property to rel and the rel_name property to the name of the referenced script item. The signal-based trigger is used by the \u201ctrial_end\u201d script item. This script item is triggered when the countdown object elicits the COUNTDOWN_FINISHED signal as specified by the \u201cwait_for_signal\u201d property. Full source code of the demo paradigm file: TODO Script Items \u00b6 The paradigm sequence is defined by script items , which must be listed in the script instance variable of your Paradigm class. The script items are processed one by one in the order in which they appear in the instance variable script . A script item can be triggered by a time event , by a signal event generated by a graphical object, or by an external LSL marker event . You can also combine different trigger types. The script item is then triggered by whichever event comes first. A script item can be defined as: ScriptItem(name='trial_start', time=10, actions=[info_text.activate]) In this example, the script item will call the method activate on the graphical object info_text at second 10 after the program start. The name of the script item is sent as an event marker in the LSL stream yaga when the item is triggered. This allows recording programs to save the paradigm state together with the LSL data streams (see Integration with LSL ). Note that the execution of script items is synchronised to the screen refresh rate (often 60 Hz). Actions \u00b6 The actions parameter of a ScriptItem expects a list of methods which are called when the action item is triggered. The available actions depend on the presentation object and are listed in Supported Graphical Objects and Auditory Objects . The actions must be specified as objects and not as method calls, i.e., without subsequent parentheses. This is to ensure that actions are executed when the script item is triggered and not at the program start when the initialisation method is executed. Some actions accept parameters. You can specify parameters by using the partial function from the functools module . The partial function allows to fix arguments and generates a new function object. This new function object is then executed when the action item is triggered. First import partial : from functools import partial Then use partial to create a new function object with a fixed set of parameters, e.g.: ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)]) In this example, targets.setActiveTarget(1) is executed when the script item is triggered. Time Triggers \u00b6 YAGA supports two types of time triggers: absolute time triggers and relative time triggers . A trigger specified with an absolute time is triggered at the specified time after the program start. A trigger specified with a relative time is triggered at the specified time relative to another script item. An absolute time trigger is the default. For example, to trigger a script item 10s after the program start, write: ScriptItem(name='trial_start', time=10, actions=[info_text.activate]) To specify a relative time trigger, set time_type to \u201crel\u201d and provide the name of the reference event with rel_name . For example, to trigger a script item 5s to 10s after the last \u201ctrial_end\u201d event, write: ScriptItem(name='trial_start', time=np.random.uniform(5, 10), time_type='rel', rel_name='trial_end', actions=[info_text.activate\\])] Signal Triggers \u00b6 A script item can wait for trigger signals generated by graphical objects. To trigger a script item with a signal, set wait_for_signal to the respective signal. The possible trigger signals are listed in Supported Graphical Objects . For example: ScriptItem(name='trial_end', wait_for_signal=GO.Countdown.COUNTDOWN_FINISHED, actions=[]) LSL Event Marker Triggers \u00b6 A script item can be triggered by an external LSL event marker generated by other programs. To listen to an LSL event marker stream, call the method listenForLSLMarkers in the paradigm file. For example, to listen for markers in the first channel of the stream streamA : self.listenForLSLMarkers(\"streamA\", lsl_marker_channel=0) The streams are expected to be event marker streams, i.e., they have an irregular sampling rate. The markers are usually variable-length ASCII strings. After setting up an LSL event listener, you can trigger script items on LSL events by specifying the marker with the parameter wait_for_lsl_marker . For example: ScriptItem(name='trial_end', wait_for_lsl_marker=\u201dtarget_reached\u201d, actions=[]) The data type of the specified marker must correspond to the data type of the LSL stream (usually a string ). Command Line Variables \u00b6 YAGA supports three general-purpose variables, which can be specified when you start YAGA.py ( var1 , var2 , var3 ). For example: python yaga.py --paradigm YOURPARADIGM --var1 someStringOrNumber The general purpose variables are accessible in the paradigm file: class Paradigm(ParadigmBase): def __init__(self, paradigm_variables): var1 = paradigm_variables['var1'] Moreover, one can specify the subject code ( string ) and session number ( integer ) with the command line parameters --subject and --session , respectively. These parameters are accessible as paradigm_variables['subject'] and paradigm_variables['session'] in the paradigm file. Graphical Objects \u00b6 Graphical objects are objects shown on the computer screen, such as text or feedback bars. They can be controllable with LSL streams, and can feature animations. To use graphical objects, one needs to import the graphic_objects module first: import yaga_modules.graphic_objects as GO A graphical object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a text object: text = self.registerObject(GO.Text('prepare for task')) Base Methods \u00b6 All graphical objects support the following methods which can be specified as actions in a ScriptItem : method parameters value type description activate - - show object on screen deactivate - - hide object on screen The position, scale, angle, and color of graphical objects can be changed with the following methods: method parameters value types description updatePos pos_x, pos_y, depth double, double, integer set x/y position and depth updateScale scale_x, scale_y double, double set x/y size updateRot angle double rotate object (in degrees) updateColor color string or 3-tuple set color Screen Coordinates \u00b6 The screen coordinates are independent of the monitor resolution. The centre of the screen corresponds to the x/y position 0. The bottom edge corresponds to a y position of -1. The top edge corresponds to an y position of 1. The coordinates of the left and right edges depend on the screen ratio. With a typical screen ratio of 16:9, the left and right edges have the x coordinate -1.78 and 1.78, respectively ((y top - y center ) x 16/9). Depth of Objects \u00b6 The depth parameter must be an integer value and specifies the depth position of objects. Objects with a smaller depth value are in front of objects with a higher depth value (the default depth is 0). Colour of Objects \u00b6 Many objects allow changing their colour. The colour must be specified as an RGB tuple with values from (0, 0, 0) to (255, 255, 255) or as a colour name ( string ). The following color names are supported: black, white, red, lime, blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy, gold, orange, and darkorange . Animated Objects \u00b6 Some graphical objects support animations. Animations can be started or stopped using an action ( startAnimation , stopAnimation ) in a ScriptItem . Furthermore, animations can generate signals which can be used as triggers for ScriptItems (e.g., trigger actions at the end of an animation). Supported Graphical Objects \u00b6 Typical graphical elements used in neuroscience experiments are implemented. The Python classes representing these elements are described in the following. Image Class \u00b6 Loads an image file from the hard disk and displays it on the computer screen. All common image formats are supported. Object Initialisation Parameters: parameter value type description file string file name of image pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle Ball Class \u00b6 Displays a filled circle on the computer screen. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size color string or 3-tuple fill color Box Class \u00b6 Displays a filled box on the computer screen. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple fill color Cross Class \u00b6 Displays a cross on the screen. Object Initialisation Parameters: parameter value type description line_width double cross line size pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple cross color Text Class \u00b6 Displays a text box on the computer screen. Optionally, a value can be read from an LSL stream and displayed on the screen as a rounded number. To read a number from an LSL stream, call the method controlStateWithLSLStream . For example: text = self.registerObject(GO.Text()) text.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[1]) Object Initialisation Parameters: parameter value type description text string text to display pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color frame_color string or 3-tuple text box frame color ScriptItem Actions: method parameters value types description updateColor color string or 3-tuple set text color updateBackgroundColor color string or 3-tuple set text box background color updateFrameColor color string or 3-tuple set text box frame color updateText text string set text RandomNumber Class \u00b6 Display a random number in a text box on the computer screen. The number is updated after each call of the method activate according to a discrete normal distribution. Object Initialisation Parameters: parameter value type description interval list of 2 integers a random number is drawn from the specified closed interval pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color; set to None to deactivate frame_color string or 3-tuple text box frame color; set to None to deactivate Countdown Class \u00b6 An animated countdown is displayed in a text box on the computer screen. The countdown is restarted after each call of the method activate . Object Initialisation Parameters: parameter value type description counter_start integer initial value of the countdown counter_stop integer final value of the countdown counter_interval double interval time in seconds pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color frame_color string or 3-tuple text box frame color ScriptItem Trigger Signals: signal description Countdown.COUNTDOWN_FINISHED elicited at the end of the countdown Bar Class \u00b6 Displays a bar for 1D feedback on the screen. The fill level of the bar is controlled with a channel from an LSL stream. Optionally, a horizontal target line can be specified. The target line position can be fixed at object initialization, updated with a call of updateTargetValue , or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter target_online_control ) or updated at discrete time points with the action updateTargetValueFromLSLStream . To set up the control of the fill level, call the method controlStateWithLSLStream and specify one control channel. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0]) To optionally control the vertical target position continuously with the same LSL stream, set target_online_control to true , and specify a second control channel. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) The vertical target position can also be controlled with a separate LSL stream by using controlStateWithLSLStream s . The second specified channel then refers to the second stream. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true)) bar.controlStateWithLSLStream([\u201cstream-A\u201d, \"stream-B\"], channels=[0, 1]) Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action updateTargetValueFromLSLStream in the respective ScriptItem objects. Note that you still need to set up the control with controlStateWithLSLStream or controlStateWithLSLStreams . For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=false)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) [...] ScriptItem(name='update_bar', time=10, actions=[bar.updateTargetValueFromLSLStream]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line low_value double LSL value corresponding to an empty bar high_value double LSL value corresponding to a fully filled bar target_value double - target value or fill level ( low_value <= target <= high_value ) - if set to None , no target will be displayed target_online_control bool - if true control the vertical target position continuously with an LSL stream - a second control channel for the target position must be specified when calling controlStateWithLSLStream or controlStateWithLSLStreams - if false , the target position can be updated with the action updateTargetValueFromLSLStream ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value updateTargetValueFromLSLStream - - - update the target value with the most recent value from an LSL stream - it is necessary to call controlStateWithLSLStream(s) before BarWithRampTarget Class \u00b6 Displays a feedback [bar]](paradigm_scripting.md#bar-class) with a ramp animation of the target. The target will transit through the following phases: pre phase: target line is at the initial position ramp up phase: target line moves upwards hold phase: target line is at the hold position ramp down phase: target line moves downwards post phase: target line is back to the initial position An additional horizontal line indicating the final ramp target will be displayed (target information) if the target animation is configured to stop below the top of the bar. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase hold_phase_duration double time duration of the hold phase ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted bar high_value double LSL value corresponding to a fully raised bar start_value double the initial position of the target ramp_value double the position of the target in the hold phase ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description BarWithRampTarget.BAR_FINISHED elicited after the end of the post phase BarWithSinusTarget Class \u00b6 Displays a feedback bar with a sinus oscillation animation of the target. The target will transit through the following phases: pre phase: target line is at the initial position ramp up phase: target line moves upwards sinus phase: target line oscillates up and down ramp down phase: target line moves downwards post phase: target line is back to the initial position An additional horizontal line indicating the oscillation center will be displayed (target information) if the oscillation center is configured to be below the top of the bar. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase sinus_phase_duration double time duration of the oscillation phase sinus_frequency double oscillation frequency in Hz sinus_amplitude double oscillation amplitude ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted bar high_value double LSL value corresponding to a fully raised bar start_value double the initial position of the target ramp_value double the center position of the sinus oscillations ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description BarWithSinusTarget.BAR_FINISHED elicited after the end of the post phase Arrow Class \u00b6 Displays an arrow for 2D feedback on the computer screen. The endpoint of the arrow is controlled with two channels from an LSL stream. Optionally, a target can be visualised as a disk above the arrow's origin. The vertical target position can be fixed at object initialization, updated with a call of updateTargetValue , or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter target_online_control ) or updated at discrete time points with the action updateTargetValueFromLSLStream . To set up the control of the arrow\u2019s endpoint, call the method controlStateWithLSLStream and specify the LSL stream and two control channels. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) To optionally control the vertical target position continuously with the same LSL stream, set target_online_control to true , and specify a third control channel. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) The vertical target position can also be controlled with a separate LSL stream by using controlStateWithLSLStream s . The third specified channel then refers to the second stream. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true)) arrow.controlStateWithLSLStreams([\u201cstream-A\u201d, \"stream-B\"], channels=[0, 1, 0]) Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action updateTargetValueFromLSLStream in the respective ScriptItem objects. Note that you still need to set up the control with controlStateWithLSLStream or controlStateWithLSLStreams . For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=false)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) [...] ScriptItem(name='update_arrow', time=10, actions=[arrow.updateTargetValueFromLSLStream]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle of the arrow arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow target_value double - target value (vertical target position) - if set to None , no target will be displayed target_online_control bool - if true , control the vertical target position continuously with an LSL stream - a third control channel for the target position must be specified when calling controlStateWithLSLStream or controlStateWithLSLStreams - if false , the target position can be updated with the action updateTargetValueFromLSLStream ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value updateTargetValueFromLSLStream - - - update the target value with the most recent value from an LSL stream - it is necessary to call controlStateWithLSLStream(s) * before ArrowWithRampTarget Class \u00b6 Displays a feedback arrow with a ramp animation of the target disk. The target will transit through the following phases: pre phase: target disk is at the initial position ramp up phase: target disk moves upwards hold phase: target disk is at the final position ramp down phase: target disk moves downwards post phase: target disk is back to the initial position An additional disk indicating the final ramp target position will be displayed (target information). Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target target_info_size double size of the target information arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase hold_phase_duration double time duration of the hold phase ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow start_value double the initial position of the target ramp_value double - the center position of the sinus oscillation - when this value is lower than the high_value , an additional hold target will be displayed ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description ArrowWithRampTarget.BAR_ARROW_FINISHED elicited after the end of the post phase ArrowWithSinusTarget Class \u00b6 Displays a feedback arrow Class with a ramp animation of the target disk. The target will transit through the following phases: pre phase: target disk is at the initial position ramp up phase: target disk moves upwards sinus phase: target disk is oscillating up & down ramp down phase: target disk moves downwards post phase: target disk is back to the initial position An additional disk indicating the position of the oscillation centre will be displayed (target information). Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target target_info_size double size of the target information arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase sinus_phase_duration double time duration of the oscillation phase sinus_frequency double oscillation frequency in Hz sinus_amplitude double oscillation amplitude ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow start_value double the initial position of the target ramp_value double - the center position of the sinus oscillation - when this value is lower than the high_value , an additional hold target will be displayed ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description ArrowWithSinusTarget.BAR_ARROW_FINISHED elicited after the end of the post phase SpikeVis Class \u00b6 Visualise discrete events, such as spikes, with flashing feedback disks. A SpikeVis object can be used as a feedback element for, e.g., the onset and termination of spike trains. SpikeVis supports multiple feedback disks and must have as many LSL control channels as feedback disks. The LSL control channels are expected to provide 0/1 values. To set up the control, call the method controlStateWithLSLStream . For example: spikes = self.registerObject(GO.SpikeVis(pos_x=0, pos_y=0, number_of_units=3)) spikes.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position number_of_units integer number of feedback disks; must correspond to the number of LSL control channels size double size of a feedback disk spacing double distance between feedback disks flash_duration double time in seconds a feedback disk flashes (activates) when a \u201c1\u201d is read from the corresponding LSL control channel active_color string or 3-tuple color of the feedback disk when inactive inactive_color string or 3-tuple color of the feedback disk when it is active ReachTargets Class \u00b6 Graphical object to implement target reaching experiments. It displays one or more disk targets which must be reached and held with a 2D cursor. The targets will be arranged in a circle around the centre. The cursor is controlled with 2 LSL channels. To set up the control, call the method controlStateWithLSLStream . For example: targetreaching = self.registerObject(GO.ReachTargets(pos_x=0, pos_y=0, number_of_targets=3)) targetreaching.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0,1]) An optional start target can be specified. Such a start target will be placed in the centre and must be reached before the actual target. The cursor must stay within the correct target area for a certain period (dwell time) to generate a target-reached signal. This target-reached signal can then be used to trigger a script item. To activate the ReachTargets object at second 10 and set the active (current) target to target 1, create a script item such as: ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)]) To end the trial when the target reached signal is generated or a 30s timeout occurs, create a script item such as: ScriptItem(name='trial_end', time=30, time_type='rel', rel_name='trial_start', wait_for_signal=GO.ReachTargets.TARGET_REACHED, actions=[targets.deactivate]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position radius double radius of the targets around the center number_of_targets integer number of targets dwell_time double dwell or hold time of targets start_target bool show a start target target_rotation double rotate targets (in degrees) target_size double target size cursor_size double cursor size target_active_color string or 3-tuple color of the active (current) target disk target_inactive_color string or 3-tuple color of the inactivate target disks target_reached_color string or 3-tuple color of the target disk when the cursor is within the target area cursor_color string or 3-tuple color of the cursor ScriptItem Actions: method parameters value types description setActiveTarget selected_target_idx integer index of the active (current) target ScriptItem Trigger Signals: signal description ReachTargets.START_TARGET_REACHED optional start target has been reached ReachTargets.TARGET_REACHED active (current) target has been reached Auditory Objects \u00b6 Auditory objects generate sounds. They can be controllable with LSL streams. To use auditory objects, one needs to import the audio_objects module first: import yaga_modules.audio_objects as AO An auditory object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a beep object: beep = self.registerObject(AO.Beep()) The Python classes representing the auditory objects are described in the following. Beep Class \u00b6 Generates a beep sound, e.g., to attract the attention of the subject. Object Initialisation Parameters: parameter value type description beep_frequency double frequency of the beep in Hz beep_amplitude double sound level beep_duration double duration of a beep in seconds beep_channels string output channels: \u201cboth\u201d, \u201cleft\u201d, or \u201cright\u201d delay double - delay the presentation of the beep - use a delay of 0.2s or more to minimise jitter ScriptItem Actions: method parameters value types description beep - - generate beep SpikeSound Class \u00b6 Generate a feedback signal for discrete events like spikes. SpikeSound supports multiple event or spike signals which can be associated with a specific sound frequency or output channel. Optionally, the sound frequencies can be dynamically modulated by the instantaneous firing rates. The events are read from an LSL stream which is expected to provide 0/1 values. To set up the LSL control call the method controlStateWithLSLStream . For example, to generate sounds for two spike signals using different sound frequencies and output channels: spikes = self.registerObject(AO.SpikeSound(beep_frequencies=\\[800, 2000\\], beep_channels=\\['left', 'right'\\])) spikes.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=\\[0, 1\\]) Object Initialisation Parameters: parameter value type description beep_frequencies list of doubles - list of frequencies in Hz - must have the same length as number of LSL channels - values must be between 100 Hz and 10 kHz beep_channels list of strings - list of output channels ( \u201cboth\u201d , \u201cleft\u201d , or \u201cright\u201d ) - must have the same length as number of LSL channels beep_duration double duration of each spike sound downsample integer downsample factor; generate a spike sound for every x^th^ spike dynamic_frq bool if true , modulate the sound frequency by the instantaneous firing rate dynamic_frq_factor integer the final sound frequency is the base frequency (from beep_frequencies ) plus the instantaneous firing rate multiplied by this factor dynamic_max_frq double limit the smoothed instantaneous firing rate to this frequency dynamic_mov_avg integer - calculate the instantaneous firing rate as the inverse of the interspike interval smoothed with a moving average window of length dynamic_mov_avg - set to None if exponential smoothing is used dynamic_exp_avg_alpha double - calculate the instantaneous firing rate as the inversive of the interspike interval smoothed with exponential smoothing using a smoothing factor of dynamic_exp_avg_alpha - set to None if the moving average is used Online Control of Objects with LSL streams \u00b6 Parameters of graphical and auditory objects can be controlled with LSL streams. The LSL streams can be read directly or processed online (scaling, filtering, etc.). The parameter updates are synchronous to the screen refresh rate. Control of Graphical Objects \u00b6 The position, scale, colour or state of graphical objects can be controlled by one or more LSL streams. For that, call the respective control method listed below. Methods for controlling a property with a single LSL stream: method parameters value types description controlPosWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string control the x/y position of an object with two channels from a single LSL stream controlScaleWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string control the x/y size of an object with two channels from a single LSL stream controlColorWithLSLStream lsl_stream_name, channel, aggregation_mode, neg_color, pos_color, neutral_color string, integer, string, string, string, string - interpolate between colors using one channel from a single LSL stream: when the value of the LSL channel is in the interval [-1, 0): interpolate between the negative and neutral color when the value of the LSL channel is in the interval [0, 1]: interpolate between the neutral and positive color - colors must be specified by their name ( string ) controlStateWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string state updates are specific to the graphical object the channels parameter of controlPosWithLSLStream and controlScaleWithLSLStream must be a list comprising two channel indices the channel parameter of controlColorWithLSLStream must be a channel index the channels parameter of controlStateWithLSLStream must be a list with one or more channel indices (the number of channels depends on the actual graphical object) for an explanation of the aggregation_mode parameter see Aggregation Mode note that channel indexing starts with a 0 in Python Methods for controlling a property with multiple LSL stream: method parameters value types description controlPosWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string control the x/y position of an object with two channels from two separate LSL streams controlScaleWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string controls the x/y size of an object with two channels from two separate LSL streams controlStateWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string currently only supported by Bar Class and Arrow Class Control of Auditory Objects \u00b6 Auditory objects support the following methods to set up LSL control. Methods for controlling a property with one or more LSL stream: method parameters value types description controlWithLSLStream stream name, channels, aggregation_mode string, list of integers, string currently only supported by SpikeSound Class controlWithLSLStreams stream names, channels, aggregation_mode list of string, list of integers, string not yet supported by any auditory object Aggregation Mode \u00b6 The LSL streams used to control the parameters of graphical or auditory objects are read and processed just before a screen refresh. All updates are therefore synchronised with the screen refresh rate, which is often 60 Hz. when the sampling frequency of an LSL stream is lower than the screen refresh rate, the LSL stream is upsampled to the screen frequency using a sample & hold strategy when the sampling frequency of an LSL stream is higher than the screen frequency, the LSL stream is downsampled strategy specified by aggregation_mode is used The following sample aggregation strategies are supported: aggregation mode value description last (default) the most recent LSL sample is used, the rest is discarded sum the LSL samples since the last read-out are summed up mean the LSL samples since the last read-out are averaged Signal Processing \u00b6 LSL streams can be processed when used to control parameters of graphical or auditory objects. The YAGA signal processing methods are applied to the original LSL stream, i.e., before any re-sampling to the screen refresh rate (see Aggregation Mode ). To use signal processing on LSL streams, import the signal_processing module : import yaga_modules.signal_processing as SP Signal processing objects can be added to the signal processing pipeline by calling the method addSignalProcessingToLSLStream . In the following example, a feedback bar is set to be controlled by an LSL stream and the LSL stream is filtered with a Butterworth low-pass filter and scaled: bar = self.registerObject(GO.Bar()) bar.controlStateWithLSLStream('the-stream, channels=[10]) butter = SP.ButterFilter(4, 5) scaler = SP.Scaler(scale=2) bar.addSignalProcessingToLSLStream(butter, channels=[10]) bar.addSignalProcessingToLSLStream(scaler, channels=[10]) The first parameter of addSignalProcessingToLSLStream is the signal processing object. The second parameter is the channel list. The number of supported channels depends on the concrete signal processing object. Important note: Make sure that signal processing objects which have a state (e.g., ButterFilter) exist only in one signal processing pipeline. If you need the same signal processing method applied to another LSL stream, create a new signal processing object. The following signal processing objects are supported by YAGA. Constant \u00b6 Set channels to a constant value. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description value double set signals to the given value CopyChannel \u00b6 Copy values from one channel to another channel. Number of supported channels: two or more Operates channel-wise: no Stateful: no Object Initialisation Parameters: parameter value type description channel_in integer index of the source channel channel_out integer index of the destination channel ButterFilter \u00b6 Filters stream with a Butterworth filter. Number of supported channels: one or more Operates channel-wise: Yes Stateful: Yes Object Initialisation Parameters: parameter value type description order integer order of the filter cutoff_frqs double or list of doubles critical frequency or frequencies: low/highpass: a scalar bandpass/stop: a 2-element list filter_type string filter type, possible values: lowpass , highpass , bandpass , bandstop Angle \u00b6 Calculates the angle in radians between the x-axis and the point given by (x,y). The first channel represents the x-coordinate, and the second channel represents the y-coordinate. Number of supported channels: two Operates channel-wise: no Stateful: no Integrate \u00b6 Integration over samples. Number of supported channels: one or more Operates channel-wise: yes Stateful: yes Object Initialisation Parameters: parameter value type description factor double multiply samples by a factor before integration Diff \u00b6 Calculates the difference between two consecutive samples. Number of supported channels: one or more Operates channel-wise: yes Stateful: yes Sum \u00b6 Calculates the sum over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no Mean \u00b6 Calculates the average over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no StdDev \u00b6 Calculates the standard deviation over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no Scaler \u00b6 Multiplies channels by a scaling factor and adds offsets before and after scaling. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description scale double scale samples by this factor pre_offset double add pre_offset before scaling post_offset double add post_offset after scaling LinearMap \u00b6 Linearly maps signals from the interval [ in_val1 , in_val2 ] to the interval [ out_val1 , out_val2 ]. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type in_val1 double in_val2 double out_val1 double out_val2 double Limit \u00b6 Limit signals to minimum and maximum values. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description min_val double minimum value max_val double maximum value Abs \u00b6 Calculates the absolute value. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Power \u00b6 Raises signals to the given power. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description exponent double exponent (power) EuclidNorm \u00b6 Calculate the Euclidean norm over channels. Number of supported channels: one or more Operates channel-wise: no Stateful: no MaxEuclidNormalizationXDF \u00b6 Normalise channels by the maximum Euclidean norm found from the data channels in the specified XDF file (e.g., force normalisation). Find maximum: load the XDF file apply a median window filter to the selected channels of the data stream subtract a common or channel-specific offset calculate the 2-norm over all selected channels find the maximum norm value over all trials Online processing: subtract offset from signals divide by the found maximum norm Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description xdf_file string XDF file to load data_stream_name string name of data stream over which the Euclidean norm is calculated (e.g., 2D force data) marker_stream_name string name of the event stream start_marker string name of a trial start event data_stream_channels list of integers channel indices of the data stream over which the Euclidean norm is calculated (if None, use all channels) offset double or list of double - subtract an offset value before calculating the Euclidean norm - to specify channel-specific offsets, specify offsets as a list with one offset value per channel - set to None to subtract the minimum of each channel filter_window_length integer filter data stream with a median filter using the specified window size in samples (must be odd) MaxAvgPowerNormalizationXDF \u00b6 Normalise channels by the maximum power found from the data channels in the specified XDF file (e.g., EMG power normalisation). Find maximum: load the XDF file apply a Butterworth bandpass filter to the selected channels of the data stream (pre-filter) calculate the signal power of all selected channels apply a moving average filter (post-filter) calculate the median signal power over all selected channels find the 90% percentile of the power over all trials Online processing: apply the pre-filter (bandpass) calculate the signal power apply the post-filter (moving average) calculate the median over channels divide signals by found 90% percentile of the power Number of supported channels: one or more Operates channel-wise: yes Stateful: yes Object Initialisation Parameters: parameter value type description xdf_file string XDF file to load data_stream_name string name of data stream over which the Euclidean norm is calculated (e.g., 2D force data) marker_stream_name string name of the event stream start_marker string name of a trial start event end_marker string name of a trial end event data_stream_channels list of integers channel indices of the data stream over which the Euclidean norm is calculated (if None , use all channels) prefilter_order Butterworth bandpass filter order prefilter_cutoff_frqs Butterworth bandpass cutoff frequencies postfilter_win_length - apply a moving average filter with the specified windows length in samples - set to 1 to deactivate filter FlappyBirdController \u00b6 Implements a Flappy Bird style 2D control with discrete events like spikes. As input, a 1D signal comprising 0/1 values is expected (e.g., spiking activity). The generated output is a 2D position signal, which can be used to control the position of other graphical objects. The control works as follows: an input activity increases the position on the currently controlled axis a short pause in the input activity switches the control between the x and y axis the x and y positions decrease at a constant velocity Note: The signal processing object expects 2 channels, but only the activity in the first channel is evaluated. The channel values will be replaced by the calculated x/y position. Number of supported channels: two Operates channel-wise: no Stateful: yes Object Initialisation Parameters: parameter value type description pos_increment double each discrete event (spike) increases the position on the currently controlled axis by this value negative_vel double decrease the position on both axes by this velocity; however, recent spiking activity prevents the currently controlled axis from this change switch_interval double minimum pause interval to switch between x and y axis x_max double limit x position to this value y_max double limit y position to this value","title":"Paradigm Scripting"},{"location":"paradigm_scripting/#paradigm-scripting","text":"","title":"Paradigm Scripting"},{"location":"paradigm_scripting/#introduction","text":"The paradigm is programmed via a so-called paradigm file . A paradigm file contains regular Python code and must define the Paradigm class , which must derive from the ParadigmBase parent class . Its code is automatically loaded when YAGA starts. A typical skeleton looks like this: from yaga_modules.paradigm_base import ParadigmBase import yaga_modules.graphic_objects as GO import yaga_modules.audio_objects as AO import yaga_modules.signal_processing as SP class Paradigm(ParadigmBase): def __init__(self, paradigm_variables): super().__init__(paradigm_variables) [\u2026]","title":"Introduction"},{"location":"paradigm_scripting/#creation-of-a-presentation-objects","text":"YAGA supports the timed presentation of several graphical or auditory objects, e.g., text, circles, or beep tones. A presentation object needs to be created within the __init__ constructor of the Paradigm class and registered to YAGA. A simple text object can be created as: info_text = self.registerObject(GO.Text('prepare for task')) In this example, GO.Text refers to the Text class defined in the graphic_objects module (GO). The call of registerObject is obligatory and registers the object to YAGA.","title":"Creation of a Presentation Objects"},{"location":"paradigm_scripting/#timing-of-presentation-objects","text":"Once an object has been created and registered, state changes of the object can be scripted, i.e., timed. For that purpose, the ParadigmBase parent class provides the instance variable script . script must be a list of ScriptItem objects. A ScripItem object specifies: a list of actions to execute when triggered the trigger (time, signal or LSL event marker) an informative name which is sent as an LSL event marker when the ScriptItem is triggered","title":"Timing of Presentation Objects"},{"location":"paradigm_scripting/#demo-paradigm","text":"The paradigm demo.py implements a simple paradigm where study participants execute a task after a Go cue. The paradigm shows an information text and a traffic light on the screen. The traffic light represents the Go cue, after which a countdown starts. While the countdown is running, the study participants would be asked to execute a specific task. The demo paradigm file shows the creation of the text, traffic light images, and countdown objects. A trial comprises the following script items: \u201ctrial_start\u201d , \u201cinfo_text\u201d , \u201ctraffic_ligh_red\u201d , \u201ctraffic_ligh_yellow\u201d , \u201ctraffic_ligh_green\u201d , \u201ccountdown\u201d , \u201ctrial_end\u201d , which are sequentially executed. Each script item specifies optionally the actions to execute when the script item is triggered. Note that the actions must be specified as objects instead of as actual method calls (i.e., no parentheses). The script list contains in total 5 (TODO) trial sequences, which are built using a for loop. The demo paradigm file demonstrates 3 possible trigger types: absolute time , relative time , and signal-based . An absolute time trigger is used by the first \u201ctrial_start\u201d script item, which is triggered 5s after the program start. However, the subsequent \u201ctrial_start\u201d script items are triggered relative to the previous \u201ctrial_end\u201d script item within a random time interval (5-10s). A relative time trigger can be requested by setting the time_type property to rel and the rel_name property to the name of the referenced script item. The signal-based trigger is used by the \u201ctrial_end\u201d script item. This script item is triggered when the countdown object elicits the COUNTDOWN_FINISHED signal as specified by the \u201cwait_for_signal\u201d property. Full source code of the demo paradigm file: TODO","title":"Demo Paradigm"},{"location":"paradigm_scripting/#script-items","text":"The paradigm sequence is defined by script items , which must be listed in the script instance variable of your Paradigm class. The script items are processed one by one in the order in which they appear in the instance variable script . A script item can be triggered by a time event , by a signal event generated by a graphical object, or by an external LSL marker event . You can also combine different trigger types. The script item is then triggered by whichever event comes first. A script item can be defined as: ScriptItem(name='trial_start', time=10, actions=[info_text.activate]) In this example, the script item will call the method activate on the graphical object info_text at second 10 after the program start. The name of the script item is sent as an event marker in the LSL stream yaga when the item is triggered. This allows recording programs to save the paradigm state together with the LSL data streams (see Integration with LSL ). Note that the execution of script items is synchronised to the screen refresh rate (often 60 Hz).","title":"Script Items"},{"location":"paradigm_scripting/#actions","text":"The actions parameter of a ScriptItem expects a list of methods which are called when the action item is triggered. The available actions depend on the presentation object and are listed in Supported Graphical Objects and Auditory Objects . The actions must be specified as objects and not as method calls, i.e., without subsequent parentheses. This is to ensure that actions are executed when the script item is triggered and not at the program start when the initialisation method is executed. Some actions accept parameters. You can specify parameters by using the partial function from the functools module . The partial function allows to fix arguments and generates a new function object. This new function object is then executed when the action item is triggered. First import partial : from functools import partial Then use partial to create a new function object with a fixed set of parameters, e.g.: ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)]) In this example, targets.setActiveTarget(1) is executed when the script item is triggered.","title":"Actions"},{"location":"paradigm_scripting/#time-triggers","text":"YAGA supports two types of time triggers: absolute time triggers and relative time triggers . A trigger specified with an absolute time is triggered at the specified time after the program start. A trigger specified with a relative time is triggered at the specified time relative to another script item. An absolute time trigger is the default. For example, to trigger a script item 10s after the program start, write: ScriptItem(name='trial_start', time=10, actions=[info_text.activate]) To specify a relative time trigger, set time_type to \u201crel\u201d and provide the name of the reference event with rel_name . For example, to trigger a script item 5s to 10s after the last \u201ctrial_end\u201d event, write: ScriptItem(name='trial_start', time=np.random.uniform(5, 10), time_type='rel', rel_name='trial_end', actions=[info_text.activate\\])]","title":"Time Triggers"},{"location":"paradigm_scripting/#signal-triggers","text":"A script item can wait for trigger signals generated by graphical objects. To trigger a script item with a signal, set wait_for_signal to the respective signal. The possible trigger signals are listed in Supported Graphical Objects . For example: ScriptItem(name='trial_end', wait_for_signal=GO.Countdown.COUNTDOWN_FINISHED, actions=[])","title":"Signal Triggers"},{"location":"paradigm_scripting/#lsl-event-marker-triggers","text":"A script item can be triggered by an external LSL event marker generated by other programs. To listen to an LSL event marker stream, call the method listenForLSLMarkers in the paradigm file. For example, to listen for markers in the first channel of the stream streamA : self.listenForLSLMarkers(\"streamA\", lsl_marker_channel=0) The streams are expected to be event marker streams, i.e., they have an irregular sampling rate. The markers are usually variable-length ASCII strings. After setting up an LSL event listener, you can trigger script items on LSL events by specifying the marker with the parameter wait_for_lsl_marker . For example: ScriptItem(name='trial_end', wait_for_lsl_marker=\u201dtarget_reached\u201d, actions=[]) The data type of the specified marker must correspond to the data type of the LSL stream (usually a string ).","title":"LSL Event Marker Triggers"},{"location":"paradigm_scripting/#command-line-variables","text":"YAGA supports three general-purpose variables, which can be specified when you start YAGA.py ( var1 , var2 , var3 ). For example: python yaga.py --paradigm YOURPARADIGM --var1 someStringOrNumber The general purpose variables are accessible in the paradigm file: class Paradigm(ParadigmBase): def __init__(self, paradigm_variables): var1 = paradigm_variables['var1'] Moreover, one can specify the subject code ( string ) and session number ( integer ) with the command line parameters --subject and --session , respectively. These parameters are accessible as paradigm_variables['subject'] and paradigm_variables['session'] in the paradigm file.","title":"Command Line Variables"},{"location":"paradigm_scripting/#graphical-objects","text":"Graphical objects are objects shown on the computer screen, such as text or feedback bars. They can be controllable with LSL streams, and can feature animations. To use graphical objects, one needs to import the graphic_objects module first: import yaga_modules.graphic_objects as GO A graphical object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a text object: text = self.registerObject(GO.Text('prepare for task'))","title":"Graphical Objects"},{"location":"paradigm_scripting/#base-methods","text":"All graphical objects support the following methods which can be specified as actions in a ScriptItem : method parameters value type description activate - - show object on screen deactivate - - hide object on screen The position, scale, angle, and color of graphical objects can be changed with the following methods: method parameters value types description updatePos pos_x, pos_y, depth double, double, integer set x/y position and depth updateScale scale_x, scale_y double, double set x/y size updateRot angle double rotate object (in degrees) updateColor color string or 3-tuple set color","title":"Base Methods"},{"location":"paradigm_scripting/#screen-coordinates","text":"The screen coordinates are independent of the monitor resolution. The centre of the screen corresponds to the x/y position 0. The bottom edge corresponds to a y position of -1. The top edge corresponds to an y position of 1. The coordinates of the left and right edges depend on the screen ratio. With a typical screen ratio of 16:9, the left and right edges have the x coordinate -1.78 and 1.78, respectively ((y top - y center ) x 16/9).","title":"Screen Coordinates"},{"location":"paradigm_scripting/#depth-of-objects","text":"The depth parameter must be an integer value and specifies the depth position of objects. Objects with a smaller depth value are in front of objects with a higher depth value (the default depth is 0).","title":"Depth of Objects"},{"location":"paradigm_scripting/#colour-of-objects","text":"Many objects allow changing their colour. The colour must be specified as an RGB tuple with values from (0, 0, 0) to (255, 255, 255) or as a colour name ( string ). The following color names are supported: black, white, red, lime, blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy, gold, orange, and darkorange .","title":"Colour of Objects"},{"location":"paradigm_scripting/#animated-objects","text":"Some graphical objects support animations. Animations can be started or stopped using an action ( startAnimation , stopAnimation ) in a ScriptItem . Furthermore, animations can generate signals which can be used as triggers for ScriptItems (e.g., trigger actions at the end of an animation).","title":"Animated Objects"},{"location":"paradigm_scripting/#supported-graphical-objects","text":"Typical graphical elements used in neuroscience experiments are implemented. The Python classes representing these elements are described in the following.","title":"Supported Graphical Objects"},{"location":"paradigm_scripting/#image-class","text":"Loads an image file from the hard disk and displays it on the computer screen. All common image formats are supported. Object Initialisation Parameters: parameter value type description file string file name of image pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle","title":"Image Class"},{"location":"paradigm_scripting/#ball-class","text":"Displays a filled circle on the computer screen. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size color string or 3-tuple fill color","title":"Ball Class"},{"location":"paradigm_scripting/#box-class","text":"Displays a filled box on the computer screen. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple fill color","title":"Box Class"},{"location":"paradigm_scripting/#cross-class","text":"Displays a cross on the screen. Object Initialisation Parameters: parameter value type description line_width double cross line size pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple cross color","title":"Cross Class"},{"location":"paradigm_scripting/#text-class","text":"Displays a text box on the computer screen. Optionally, a value can be read from an LSL stream and displayed on the screen as a rounded number. To read a number from an LSL stream, call the method controlStateWithLSLStream . For example: text = self.registerObject(GO.Text()) text.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[1]) Object Initialisation Parameters: parameter value type description text string text to display pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color frame_color string or 3-tuple text box frame color ScriptItem Actions: method parameters value types description updateColor color string or 3-tuple set text color updateBackgroundColor color string or 3-tuple set text box background color updateFrameColor color string or 3-tuple set text box frame color updateText text string set text","title":"Text Class"},{"location":"paradigm_scripting/#randomnumber-class","text":"Display a random number in a text box on the computer screen. The number is updated after each call of the method activate according to a discrete normal distribution. Object Initialisation Parameters: parameter value type description interval list of 2 integers a random number is drawn from the specified closed interval pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color; set to None to deactivate frame_color string or 3-tuple text box frame color; set to None to deactivate","title":"RandomNumber Class"},{"location":"paradigm_scripting/#countdown-class","text":"An animated countdown is displayed in a text box on the computer screen. The countdown is restarted after each call of the method activate . Object Initialisation Parameters: parameter value type description counter_start integer initial value of the countdown counter_stop integer final value of the countdown counter_interval double interval time in seconds pox_x double horizontal position pos_y double vertical position depth integer depth position scale_x double horizontal size scale_y double vertical size angle double rotation angle color string or 3-tuple text color background_color string or 3-tuple text box background color frame_color string or 3-tuple text box frame color ScriptItem Trigger Signals: signal description Countdown.COUNTDOWN_FINISHED elicited at the end of the countdown","title":"Countdown Class"},{"location":"paradigm_scripting/#bar-class","text":"Displays a bar for 1D feedback on the screen. The fill level of the bar is controlled with a channel from an LSL stream. Optionally, a horizontal target line can be specified. The target line position can be fixed at object initialization, updated with a call of updateTargetValue , or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter target_online_control ) or updated at discrete time points with the action updateTargetValueFromLSLStream . To set up the control of the fill level, call the method controlStateWithLSLStream and specify one control channel. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0]) To optionally control the vertical target position continuously with the same LSL stream, set target_online_control to true , and specify a second control channel. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) The vertical target position can also be controlled with a separate LSL stream by using controlStateWithLSLStream s . The second specified channel then refers to the second stream. For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true)) bar.controlStateWithLSLStream([\u201cstream-A\u201d, \"stream-B\"], channels=[0, 1]) Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action updateTargetValueFromLSLStream in the respective ScriptItem objects. Note that you still need to set up the control with controlStateWithLSLStream or controlStateWithLSLStreams . For example: bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=false)) bar.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) [...] ScriptItem(name='update_bar', time=10, actions=[bar.updateTargetValueFromLSLStream]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line low_value double LSL value corresponding to an empty bar high_value double LSL value corresponding to a fully filled bar target_value double - target value or fill level ( low_value <= target <= high_value ) - if set to None , no target will be displayed target_online_control bool - if true control the vertical target position continuously with an LSL stream - a second control channel for the target position must be specified when calling controlStateWithLSLStream or controlStateWithLSLStreams - if false , the target position can be updated with the action updateTargetValueFromLSLStream ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value updateTargetValueFromLSLStream - - - update the target value with the most recent value from an LSL stream - it is necessary to call controlStateWithLSLStream(s) before","title":"Bar Class"},{"location":"paradigm_scripting/#barwithramptarget-class","text":"Displays a feedback [bar]](paradigm_scripting.md#bar-class) with a ramp animation of the target. The target will transit through the following phases: pre phase: target line is at the initial position ramp up phase: target line moves upwards hold phase: target line is at the hold position ramp down phase: target line moves downwards post phase: target line is back to the initial position An additional horizontal line indicating the final ramp target will be displayed (target information) if the target animation is configured to stop below the top of the bar. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase hold_phase_duration double time duration of the hold phase ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted bar high_value double LSL value corresponding to a fully raised bar start_value double the initial position of the target ramp_value double the position of the target in the hold phase ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description BarWithRampTarget.BAR_FINISHED elicited after the end of the post phase","title":"BarWithRampTarget Class"},{"location":"paradigm_scripting/#barwithsinustarget-class","text":"Displays a feedback bar with a sinus oscillation animation of the target. The target will transit through the following phases: pre phase: target line is at the initial position ramp up phase: target line moves upwards sinus phase: target line oscillates up and down ramp down phase: target line moves downwards post phase: target line is back to the initial position An additional horizontal line indicating the oscillation center will be displayed (target information) if the oscillation center is configured to be below the top of the bar. Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position bar_width double width of the bar bar_height double height of the bar when fully raised frame_width double thickness of the frame around the bar target_width double width of the target line target_height double height of the target line bar_color string or 3-tuple color of the bar frame_color string or 3-tuple color of the bar frame target_color string or 3-tuple color of the target line target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase sinus_phase_duration double time duration of the oscillation phase sinus_frequency double oscillation frequency in Hz sinus_amplitude double oscillation amplitude ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted bar high_value double LSL value corresponding to a fully raised bar start_value double the initial position of the target ramp_value double the center position of the sinus oscillations ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description BarWithSinusTarget.BAR_FINISHED elicited after the end of the post phase","title":"BarWithSinusTarget Class"},{"location":"paradigm_scripting/#arrow-class","text":"Displays an arrow for 2D feedback on the computer screen. The endpoint of the arrow is controlled with two channels from an LSL stream. Optionally, a target can be visualised as a disk above the arrow's origin. The vertical target position can be fixed at object initialization, updated with a call of updateTargetValue , or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter target_online_control ) or updated at discrete time points with the action updateTargetValueFromLSLStream . To set up the control of the arrow\u2019s endpoint, call the method controlStateWithLSLStream and specify the LSL stream and two control channels. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1]) To optionally control the vertical target position continuously with the same LSL stream, set target_online_control to true , and specify a third control channel. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) The vertical target position can also be controlled with a separate LSL stream by using controlStateWithLSLStream s . The third specified channel then refers to the second stream. For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true)) arrow.controlStateWithLSLStreams([\u201cstream-A\u201d, \"stream-B\"], channels=[0, 1, 0]) Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action updateTargetValueFromLSLStream in the respective ScriptItem objects. Note that you still need to set up the control with controlStateWithLSLStream or controlStateWithLSLStreams . For example: arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=false)) arrow.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) [...] ScriptItem(name='update_arrow', time=10, actions=[arrow.updateTargetValueFromLSLStream]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle of the arrow arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow target_value double - target value (vertical target position) - if set to None , no target will be displayed target_online_control bool - if true , control the vertical target position continuously with an LSL stream - a third control channel for the target position must be specified when calling controlStateWithLSLStream or controlStateWithLSLStreams - if false , the target position can be updated with the action updateTargetValueFromLSLStream ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value updateTargetValueFromLSLStream - - - update the target value with the most recent value from an LSL stream - it is necessary to call controlStateWithLSLStream(s) * before","title":"Arrow Class"},{"location":"paradigm_scripting/#arrowwithramptarget-class","text":"Displays a feedback arrow with a ramp animation of the target disk. The target will transit through the following phases: pre phase: target disk is at the initial position ramp up phase: target disk moves upwards hold phase: target disk is at the final position ramp down phase: target disk moves downwards post phase: target disk is back to the initial position An additional disk indicating the final ramp target position will be displayed (target information). Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target target_info_size double size of the target information arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase hold_phase_duration double time duration of the hold phase ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow start_value double the initial position of the target ramp_value double - the center position of the sinus oscillation - when this value is lower than the high_value , an additional hold target will be displayed ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description ArrowWithRampTarget.BAR_ARROW_FINISHED elicited after the end of the post phase","title":"ArrowWithRampTarget Class"},{"location":"paradigm_scripting/#arrowwithsinustarget-class","text":"Displays a feedback arrow Class with a ramp animation of the target disk. The target will transit through the following phases: pre phase: target disk is at the initial position ramp up phase: target disk moves upwards sinus phase: target disk is oscillating up & down ramp down phase: target disk moves downwards post phase: target disk is back to the initial position An additional disk indicating the position of the oscillation centre will be displayed (target information). Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position angle double rotation angle arrow_length double length of the arrow when fully extended line_width double width of the arrow head_size double head size of the arrow target_size double size of the target target_info_size double size of the target information arrow_color string or 3-tuple color of the arrow target_color string or 3-tuple color of the target target_info_color string or 3-tuple color of the target information pre_phase_duration double time duration of the pre phase ramp_up_phase_duration double time duration of the ramp up phase sinus_phase_duration double time duration of the oscillation phase sinus_frequency double oscillation frequency in Hz sinus_amplitude double oscillation amplitude ramp_down_phase_duration double time duration of the ramp down phase post_phase_duration double time duration of the post phase low_value double LSL value corresponding to a fully contracted arrow high_value double LSL value corresponding to a fully extended arrow start_value double the initial position of the target ramp_value double - the center position of the sinus oscillation - when this value is lower than the high_value , an additional hold target will be displayed ScriptItem Actions: method parameters value types description updateTargetValue target_value double update the target value startAnimation - - start ramp animation stopAnimation - - stop ramp animation ScriptItem Trigger Signals: signal description ArrowWithSinusTarget.BAR_ARROW_FINISHED elicited after the end of the post phase","title":"ArrowWithSinusTarget Class"},{"location":"paradigm_scripting/#spikevis-class","text":"Visualise discrete events, such as spikes, with flashing feedback disks. A SpikeVis object can be used as a feedback element for, e.g., the onset and termination of spike trains. SpikeVis supports multiple feedback disks and must have as many LSL control channels as feedback disks. The LSL control channels are expected to provide 0/1 values. To set up the control, call the method controlStateWithLSLStream . For example: spikes = self.registerObject(GO.SpikeVis(pos_x=0, pos_y=0, number_of_units=3)) spikes.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0, 1, 2]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position number_of_units integer number of feedback disks; must correspond to the number of LSL control channels size double size of a feedback disk spacing double distance between feedback disks flash_duration double time in seconds a feedback disk flashes (activates) when a \u201c1\u201d is read from the corresponding LSL control channel active_color string or 3-tuple color of the feedback disk when inactive inactive_color string or 3-tuple color of the feedback disk when it is active","title":"SpikeVis Class"},{"location":"paradigm_scripting/#reachtargets-class","text":"Graphical object to implement target reaching experiments. It displays one or more disk targets which must be reached and held with a 2D cursor. The targets will be arranged in a circle around the centre. The cursor is controlled with 2 LSL channels. To set up the control, call the method controlStateWithLSLStream . For example: targetreaching = self.registerObject(GO.ReachTargets(pos_x=0, pos_y=0, number_of_targets=3)) targetreaching.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=[0,1]) An optional start target can be specified. Such a start target will be placed in the centre and must be reached before the actual target. The cursor must stay within the correct target area for a certain period (dwell time) to generate a target-reached signal. This target-reached signal can then be used to trigger a script item. To activate the ReachTargets object at second 10 and set the active (current) target to target 1, create a script item such as: ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)]) To end the trial when the target reached signal is generated or a 30s timeout occurs, create a script item such as: ScriptItem(name='trial_end', time=30, time_type='rel', rel_name='trial_start', wait_for_signal=GO.ReachTargets.TARGET_REACHED, actions=[targets.deactivate]) Object Initialisation Parameters: parameter value type description pox_x double horizontal position pos_y double vertical position depth integer depth position radius double radius of the targets around the center number_of_targets integer number of targets dwell_time double dwell or hold time of targets start_target bool show a start target target_rotation double rotate targets (in degrees) target_size double target size cursor_size double cursor size target_active_color string or 3-tuple color of the active (current) target disk target_inactive_color string or 3-tuple color of the inactivate target disks target_reached_color string or 3-tuple color of the target disk when the cursor is within the target area cursor_color string or 3-tuple color of the cursor ScriptItem Actions: method parameters value types description setActiveTarget selected_target_idx integer index of the active (current) target ScriptItem Trigger Signals: signal description ReachTargets.START_TARGET_REACHED optional start target has been reached ReachTargets.TARGET_REACHED active (current) target has been reached","title":"ReachTargets Class"},{"location":"paradigm_scripting/#auditory-objects","text":"Auditory objects generate sounds. They can be controllable with LSL streams. To use auditory objects, one needs to import the audio_objects module first: import yaga_modules.audio_objects as AO An auditory object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a beep object: beep = self.registerObject(AO.Beep()) The Python classes representing the auditory objects are described in the following.","title":"Auditory Objects"},{"location":"paradigm_scripting/#beep-class","text":"Generates a beep sound, e.g., to attract the attention of the subject. Object Initialisation Parameters: parameter value type description beep_frequency double frequency of the beep in Hz beep_amplitude double sound level beep_duration double duration of a beep in seconds beep_channels string output channels: \u201cboth\u201d, \u201cleft\u201d, or \u201cright\u201d delay double - delay the presentation of the beep - use a delay of 0.2s or more to minimise jitter ScriptItem Actions: method parameters value types description beep - - generate beep","title":"Beep Class"},{"location":"paradigm_scripting/#spikesound-class","text":"Generate a feedback signal for discrete events like spikes. SpikeSound supports multiple event or spike signals which can be associated with a specific sound frequency or output channel. Optionally, the sound frequencies can be dynamically modulated by the instantaneous firing rates. The events are read from an LSL stream which is expected to provide 0/1 values. To set up the LSL control call the method controlStateWithLSLStream . For example, to generate sounds for two spike signals using different sound frequencies and output channels: spikes = self.registerObject(AO.SpikeSound(beep_frequencies=\\[800, 2000\\], beep_channels=\\['left', 'right'\\])) spikes.controlStateWithLSLStream(\u201cthe-stream\u201d, channels=\\[0, 1\\]) Object Initialisation Parameters: parameter value type description beep_frequencies list of doubles - list of frequencies in Hz - must have the same length as number of LSL channels - values must be between 100 Hz and 10 kHz beep_channels list of strings - list of output channels ( \u201cboth\u201d , \u201cleft\u201d , or \u201cright\u201d ) - must have the same length as number of LSL channels beep_duration double duration of each spike sound downsample integer downsample factor; generate a spike sound for every x^th^ spike dynamic_frq bool if true , modulate the sound frequency by the instantaneous firing rate dynamic_frq_factor integer the final sound frequency is the base frequency (from beep_frequencies ) plus the instantaneous firing rate multiplied by this factor dynamic_max_frq double limit the smoothed instantaneous firing rate to this frequency dynamic_mov_avg integer - calculate the instantaneous firing rate as the inverse of the interspike interval smoothed with a moving average window of length dynamic_mov_avg - set to None if exponential smoothing is used dynamic_exp_avg_alpha double - calculate the instantaneous firing rate as the inversive of the interspike interval smoothed with exponential smoothing using a smoothing factor of dynamic_exp_avg_alpha - set to None if the moving average is used","title":"SpikeSound Class"},{"location":"paradigm_scripting/#online-control-of-objects-with-lsl-streams","text":"Parameters of graphical and auditory objects can be controlled with LSL streams. The LSL streams can be read directly or processed online (scaling, filtering, etc.). The parameter updates are synchronous to the screen refresh rate.","title":"Online Control of Objects with LSL streams"},{"location":"paradigm_scripting/#control-of-graphical-objects","text":"The position, scale, colour or state of graphical objects can be controlled by one or more LSL streams. For that, call the respective control method listed below. Methods for controlling a property with a single LSL stream: method parameters value types description controlPosWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string control the x/y position of an object with two channels from a single LSL stream controlScaleWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string control the x/y size of an object with two channels from a single LSL stream controlColorWithLSLStream lsl_stream_name, channel, aggregation_mode, neg_color, pos_color, neutral_color string, integer, string, string, string, string - interpolate between colors using one channel from a single LSL stream: when the value of the LSL channel is in the interval [-1, 0): interpolate between the negative and neutral color when the value of the LSL channel is in the interval [0, 1]: interpolate between the neutral and positive color - colors must be specified by their name ( string ) controlStateWithLSLStream lsl_stream_name, channels, aggregation_mode string, list of integers, string state updates are specific to the graphical object the channels parameter of controlPosWithLSLStream and controlScaleWithLSLStream must be a list comprising two channel indices the channel parameter of controlColorWithLSLStream must be a channel index the channels parameter of controlStateWithLSLStream must be a list with one or more channel indices (the number of channels depends on the actual graphical object) for an explanation of the aggregation_mode parameter see Aggregation Mode note that channel indexing starts with a 0 in Python Methods for controlling a property with multiple LSL stream: method parameters value types description controlPosWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string control the x/y position of an object with two channels from two separate LSL streams controlScaleWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string controls the x/y size of an object with two channels from two separate LSL streams controlStateWithLSLStreams lsl_stream_names, channels, aggregation_mode list of strings, list of integers, string currently only supported by Bar Class and Arrow Class","title":"Control of Graphical Objects"},{"location":"paradigm_scripting/#control-of-auditory-objects","text":"Auditory objects support the following methods to set up LSL control. Methods for controlling a property with one or more LSL stream: method parameters value types description controlWithLSLStream stream name, channels, aggregation_mode string, list of integers, string currently only supported by SpikeSound Class controlWithLSLStreams stream names, channels, aggregation_mode list of string, list of integers, string not yet supported by any auditory object","title":"Control of Auditory Objects"},{"location":"paradigm_scripting/#aggregation-mode","text":"The LSL streams used to control the parameters of graphical or auditory objects are read and processed just before a screen refresh. All updates are therefore synchronised with the screen refresh rate, which is often 60 Hz. when the sampling frequency of an LSL stream is lower than the screen refresh rate, the LSL stream is upsampled to the screen frequency using a sample & hold strategy when the sampling frequency of an LSL stream is higher than the screen frequency, the LSL stream is downsampled strategy specified by aggregation_mode is used The following sample aggregation strategies are supported: aggregation mode value description last (default) the most recent LSL sample is used, the rest is discarded sum the LSL samples since the last read-out are summed up mean the LSL samples since the last read-out are averaged","title":"Aggregation Mode"},{"location":"paradigm_scripting/#signal-processing","text":"LSL streams can be processed when used to control parameters of graphical or auditory objects. The YAGA signal processing methods are applied to the original LSL stream, i.e., before any re-sampling to the screen refresh rate (see Aggregation Mode ). To use signal processing on LSL streams, import the signal_processing module : import yaga_modules.signal_processing as SP Signal processing objects can be added to the signal processing pipeline by calling the method addSignalProcessingToLSLStream . In the following example, a feedback bar is set to be controlled by an LSL stream and the LSL stream is filtered with a Butterworth low-pass filter and scaled: bar = self.registerObject(GO.Bar()) bar.controlStateWithLSLStream('the-stream, channels=[10]) butter = SP.ButterFilter(4, 5) scaler = SP.Scaler(scale=2) bar.addSignalProcessingToLSLStream(butter, channels=[10]) bar.addSignalProcessingToLSLStream(scaler, channels=[10]) The first parameter of addSignalProcessingToLSLStream is the signal processing object. The second parameter is the channel list. The number of supported channels depends on the concrete signal processing object. Important note: Make sure that signal processing objects which have a state (e.g., ButterFilter) exist only in one signal processing pipeline. If you need the same signal processing method applied to another LSL stream, create a new signal processing object. The following signal processing objects are supported by YAGA.","title":"Signal Processing"},{"location":"paradigm_scripting/#constant","text":"Set channels to a constant value. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description value double set signals to the given value","title":"Constant"},{"location":"paradigm_scripting/#copychannel","text":"Copy values from one channel to another channel. Number of supported channels: two or more Operates channel-wise: no Stateful: no Object Initialisation Parameters: parameter value type description channel_in integer index of the source channel channel_out integer index of the destination channel","title":"CopyChannel"},{"location":"paradigm_scripting/#butterfilter","text":"Filters stream with a Butterworth filter. Number of supported channels: one or more Operates channel-wise: Yes Stateful: Yes Object Initialisation Parameters: parameter value type description order integer order of the filter cutoff_frqs double or list of doubles critical frequency or frequencies: low/highpass: a scalar bandpass/stop: a 2-element list filter_type string filter type, possible values: lowpass , highpass , bandpass , bandstop","title":"ButterFilter"},{"location":"paradigm_scripting/#angle","text":"Calculates the angle in radians between the x-axis and the point given by (x,y). The first channel represents the x-coordinate, and the second channel represents the y-coordinate. Number of supported channels: two Operates channel-wise: no Stateful: no","title":"Angle"},{"location":"paradigm_scripting/#integrate","text":"Integration over samples. Number of supported channels: one or more Operates channel-wise: yes Stateful: yes Object Initialisation Parameters: parameter value type description factor double multiply samples by a factor before integration","title":"Integrate"},{"location":"paradigm_scripting/#diff","text":"Calculates the difference between two consecutive samples. Number of supported channels: one or more Operates channel-wise: yes Stateful: yes","title":"Diff"},{"location":"paradigm_scripting/#sum","text":"Calculates the sum over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no","title":"Sum"},{"location":"paradigm_scripting/#mean","text":"Calculates the average over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no","title":"Mean"},{"location":"paradigm_scripting/#stddev","text":"Calculates the standard deviation over channels. Number of supported channels: two or more Operates channel-wise: no Stateful: no","title":"StdDev"},{"location":"paradigm_scripting/#scaler","text":"Multiplies channels by a scaling factor and adds offsets before and after scaling. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description scale double scale samples by this factor pre_offset double add pre_offset before scaling post_offset double add post_offset after scaling","title":"Scaler"},{"location":"paradigm_scripting/#linearmap","text":"Linearly maps signals from the interval [ in_val1 , in_val2 ] to the interval [ out_val1 , out_val2 ]. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type in_val1 double in_val2 double out_val1 double out_val2 double","title":"LinearMap"},{"location":"paradigm_scripting/#limit","text":"Limit signals to minimum and maximum values. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description min_val double minimum value max_val double maximum value","title":"Limit"},{"location":"paradigm_scripting/#abs","text":"Calculates the absolute value. Number of supported channels: one or more Operates channel-wise: yes Stateful: no","title":"Abs"},{"location":"paradigm_scripting/#power","text":"Raises signals to the given power. Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description exponent double exponent (power)","title":"Power"},{"location":"paradigm_scripting/#euclidnorm","text":"Calculate the Euclidean norm over channels. Number of supported channels: one or more Operates channel-wise: no Stateful: no","title":"EuclidNorm"},{"location":"paradigm_scripting/#maxeuclidnormalizationxdf","text":"Normalise channels by the maximum Euclidean norm found from the data channels in the specified XDF file (e.g., force normalisation). Find maximum: load the XDF file apply a median window filter to the selected channels of the data stream subtract a common or channel-specific offset calculate the 2-norm over all selected channels find the maximum norm value over all trials Online processing: subtract offset from signals divide by the found maximum norm Number of supported channels: one or more Operates channel-wise: yes Stateful: no Object Initialisation Parameters: parameter value type description xdf_file string XDF file to load data_stream_name string name of data stream over which the Euclidean norm is calculated (e.g., 2D force data) marker_stream_name string name of the event stream start_marker string name of a trial start event data_stream_channels list of integers channel indices of the data stream over which the Euclidean norm is calculated (if None, use all channels) offset double or list of double - subtract an offset value before calculating the Euclidean norm - to specify channel-specific offsets, specify offsets as a list with one offset value per channel - set to None to subtract the minimum of each channel filter_window_length integer filter data stream with a median filter using the specified window size in samples (must be odd)","title":"MaxEuclidNormalizationXDF"},{"location":"paradigm_scripting/#maxavgpowernormalizationxdf","text":"Normalise channels by the maximum power found from the data channels in the specified XDF file (e.g., EMG power normalisation). Find maximum: load the XDF file apply a Butterworth bandpass filter to the selected channels of the data stream (pre-filter) calculate the signal power of all selected channels apply a moving average filter (post-filter) calculate the median signal power over all selected channels find the 90% percentile of the power over all trials Online processing: apply the pre-filter (bandpass) calculate the signal power apply the post-filter (moving average) calculate the median over channels divide signals by found 90% percentile of the power Number of supported channels: one or more Operates channel-wise: yes Stateful: yes Object Initialisation Parameters: parameter value type description xdf_file string XDF file to load data_stream_name string name of data stream over which the Euclidean norm is calculated (e.g., 2D force data) marker_stream_name string name of the event stream start_marker string name of a trial start event end_marker string name of a trial end event data_stream_channels list of integers channel indices of the data stream over which the Euclidean norm is calculated (if None , use all channels) prefilter_order Butterworth bandpass filter order prefilter_cutoff_frqs Butterworth bandpass cutoff frequencies postfilter_win_length - apply a moving average filter with the specified windows length in samples - set to 1 to deactivate filter","title":"MaxAvgPowerNormalizationXDF"},{"location":"paradigm_scripting/#flappybirdcontroller","text":"Implements a Flappy Bird style 2D control with discrete events like spikes. As input, a 1D signal comprising 0/1 values is expected (e.g., spiking activity). The generated output is a 2D position signal, which can be used to control the position of other graphical objects. The control works as follows: an input activity increases the position on the currently controlled axis a short pause in the input activity switches the control between the x and y axis the x and y positions decrease at a constant velocity Note: The signal processing object expects 2 channels, but only the activity in the first channel is evaluated. The channel values will be replaced by the calculated x/y position. Number of supported channels: two Operates channel-wise: no Stateful: yes Object Initialisation Parameters: parameter value type description pos_increment double each discrete event (spike) increases the position on the currently controlled axis by this value negative_vel double decrease the position on both axes by this velocity; however, recent spiking activity prevents the currently controlled axis from this change switch_interval double minimum pause interval to switch between x and y axis x_max double limit x position to this value y_max double limit y position to this value","title":"FlappyBirdController"},{"location":"release_notes/","text":"","title":"Release Notes"},{"location":"start_of_yaga/","text":"Start of YAGA \u00b6 YAGA is started from the command line as: python yaga.py [OPTIONS] A paradigm file has to be specified with the -p or --paradigm command line parameter. YAGA will look in the paradigms subfolder for the specified paradigm file. For example, to start the demo paradigm use this command: python yaga.py --paradigm demo.py Here is a full list of command line options: option (short version) option (long version) description -h --help show information -p STRING --paradigm STRING specify the paradigm file to load (necessary) -m --maximize maximise application window --subject STRING specify the subject code --session NUMBER specify the session number --run NUMBER specify the run number --var1 STRING general purpose variable 1 --var2 STRING general purpose variable 2 --var3 STRING general purpose variable 3 The subject code, session and run number are used to select the directory and filename where the recorded data will be saved (see Integration with LSL ). Moreover, the code in the paradigm file can also make use of this information and, e.g., load subject-specific data. The general purpose variables can be used to specify options for a paradigm (e.g., select a condition). The paradigm option is always obligatory; the other options may be required by the paradigm file.","title":"Start of YAGA"},{"location":"start_of_yaga/#start-of-yaga","text":"YAGA is started from the command line as: python yaga.py [OPTIONS] A paradigm file has to be specified with the -p or --paradigm command line parameter. YAGA will look in the paradigms subfolder for the specified paradigm file. For example, to start the demo paradigm use this command: python yaga.py --paradigm demo.py Here is a full list of command line options: option (short version) option (long version) description -h --help show information -p STRING --paradigm STRING specify the paradigm file to load (necessary) -m --maximize maximise application window --subject STRING specify the subject code --session NUMBER specify the session number --run NUMBER specify the run number --var1 STRING general purpose variable 1 --var2 STRING general purpose variable 2 --var3 STRING general purpose variable 3 The subject code, session and run number are used to select the directory and filename where the recorded data will be saved (see Integration with LSL ). Moreover, the code in the paradigm file can also make use of this information and, e.g., load subject-specific data. The general purpose variables can be used to specify options for a paradigm (e.g., select a condition). The paradigm option is always obligatory; the other options may be required by the paradigm file.","title":"Start of YAGA"}]}