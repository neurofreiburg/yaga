<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Patrick Ofner" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Paradigm Scripting - YAGA</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Paradigm Scripting";
        var mkdocs_page_input_path = "paradigm_scripting.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> YAGA
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../start_of_yaga/">Start of YAGA</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Paradigm Scripting</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creation-of-a-presentation-objects">Creation of a Presentation Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#timing-of-presentation-objects">Timing of Presentation Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#demo-paradigm">Demo Paradigm</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#script-items">Script Items</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#actions">Actions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time-triggers">Time Triggers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#signal-triggers">Signal Triggers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lsl-event-marker-triggers">LSL Event Marker Triggers</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#command-line-variables">Command Line Variables</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#graphical-objects">Graphical Objects</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#base-methods">Base Methods</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#screen-coordinates">Screen Coordinates</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#depth-of-objects">Depth of Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#colour-of-objects">Colour of Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#animated-objects">Animated Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#supported-graphical-objects">Supported Graphical Objects</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#image-class">Image Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ball-class">Ball Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#box-class">Box Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cross-class">Cross Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#text-class">Text Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#randomnumber-class">RandomNumber Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#countdown-class">Countdown Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#bar-class">Bar Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#barwithramptarget-class">BarWithRampTarget Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#barwithsinustarget-class">BarWithSinusTarget Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#arrow-class">Arrow Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#arrowwithramptarget-class">ArrowWithRampTarget Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#arrowwithsinustarget-class">ArrowWithSinusTarget Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spikevis-class">SpikeVis Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reachtargets-class">ReachTargets Class</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#auditory-objects">Auditory Objects</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beep-class">Beep Class</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#spikesound-class">SpikeSound Class</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#online-control-of-objects-with-lsl-streams">Online Control of Objects with LSL streams</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#control-of-graphical-objects">Control of Graphical Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#control-of-auditory-objects">Control of Auditory Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#aggregation-mode">Aggregation Mode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#signal-processing">Signal Processing</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#constant">Constant</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#copychannel">CopyChannel</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#butterfilter">ButterFilter</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#angle">Angle</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integrate">Integrate</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#diff">Diff</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sum">Sum</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mean">Mean</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#stddev">StdDev</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scaler">Scaler</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#linearmap">LinearMap</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#limit">Limit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#abs">Abs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#power">Power</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#euclidnorm">EuclidNorm</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxeuclidnormalizationxdf">MaxEuclidNormalizationXDF</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxavgpowernormalizationxdf">MaxAvgPowerNormalizationXDF</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#flappybirdcontroller">FlappyBirdController</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../integration_with_lsl/">Integration with Lab Streaming Layer (LSL)</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../license/">License</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_notes/">Release Notes</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">YAGA</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Paradigm Scripting</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/neurofreiburg/yaga/edit/master/docs/paradigm_scripting.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="paradigm-scripting">Paradigm Scripting<a class="headerlink" href="#paradigm-scripting" title="Permanent link">&para;</a></h1>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>The paradigm is programmed via a so-called <em>paradigm file</em>. A paradigm file contains regular Python code and must define the <strong>Paradigm class</strong>, which must derive from the <strong>ParadigmBase parent class</strong>. Its code is automatically loaded when YAGA starts. A typical skeleton looks like this:</p>
<pre><code>from yaga_modules.paradigm_base import ParadigmBase
import yaga_modules.graphic_objects as GO
import yaga_modules.audio_objects as AO
import yaga_modules.signal_processing as SP

class Paradigm(ParadigmBase):
    def __init__(self, paradigm_variables):
        super().__init__(paradigm_variables)
        […]
</code></pre>
<h3 id="creation-of-a-presentation-objects">Creation of a Presentation Objects<a class="headerlink" href="#creation-of-a-presentation-objects" title="Permanent link">&para;</a></h3>
<p>YAGA supports the timed presentation of several graphical or auditory objects, e.g., text, circles, or beep tones. A presentation object needs to be created within the <strong>__init__</strong> constructor of the <strong>Paradigm class</strong> and registered to YAGA. A simple text object can be created as:</p>
<p><code>info_text = self.registerObject(GO.Text('prepare for task'))</code></p>
<p>In this example, <strong>GO.Text</strong> refers to the <strong>Text class</strong> defined in the <strong>graphic_objects module</strong> (GO). The call of <strong>registerObject</strong> is obligatory and registers the object to YAGA.</p>
<h3 id="timing-of-presentation-objects">Timing of Presentation Objects<a class="headerlink" href="#timing-of-presentation-objects" title="Permanent link">&para;</a></h3>
<p>Once an object has been created and registered, state changes of the object can be scripted, i.e., timed. For that purpose, the <strong>ParadigmBase parent class</strong> provides the instance variable <strong>script</strong>. <strong>script</strong> must be a list of <strong>ScriptItem</strong> objects.</p>
<p>A <strong>ScripItem</strong> object specifies:</p>
<ol>
<li>a list of actions to execute when triggered</li>
<li>the trigger (time, signal or LSL event marker)</li>
<li>an informative name which is sent as an LSL event marker when the <strong>ScriptItem</strong> is triggered</li>
</ol>
<h3 id="demo-paradigm">Demo Paradigm<a class="headerlink" href="#demo-paradigm" title="Permanent link">&para;</a></h3>
<p>The paradigm <em>demo.py</em> implements a simple paradigm where study participants execute a task after a Go cue. The paradigm shows an information text and a traffic light on the screen. The traffic light represents the Go cue, after which a countdown starts. While the countdown is running, the study participants would be asked to execute a specific task. The demo paradigm file shows the creation of the text, traffic light images, and countdown objects.</p>
<p>A trial comprises the following script items: <em>“trial_start”</em>, <em>“info_text”</em>, <em>“traffic_ligh_red”</em>, <em>“traffic_ligh_yellow”</em>, <em>“traffic_ligh_green”</em>, <em>“countdown”</em>, <em>“trial_end”</em>, which are sequentially executed. Each script item specifies optionally the actions to execute when the script item is triggered. Note that the actions must be specified as objects instead of as actual method calls (i.e., no parentheses). The <strong>script</strong> list contains in total 5 (TODO) trial sequences, which are built using a for loop.</p>
<p>The demo paradigm file demonstrates 3 possible trigger types: <strong>absolute time</strong>, <strong>relative time</strong>, and <strong>signal-based</strong>. An absolute time trigger is used by the first <em>“trial_start”</em> script item, which is triggered 5s after the program start. However, the subsequent <em>“trial_start”</em> script items are triggered relative to the previous <em>“trial_end”</em> script item within a random time interval (5-10s). A relative time trigger can be requested by setting the <strong>time_type</strong> property to <strong>rel</strong> and the <strong>rel_name</strong> property to the name of the referenced script item. The signal-based trigger is used by the <em>“trial_end”</em> script item. This script item is triggered when the countdown object elicits the <strong>COUNTDOWN_FINISHED</strong> signal as specified by the <em>“wait_for_signal”</em> property.</p>
<p>Full source code of the demo paradigm file:</p>
<pre><code>TODO
</code></pre>
<h2 id="script-items">Script Items<a class="headerlink" href="#script-items" title="Permanent link">&para;</a></h2>
<p>The paradigm sequence is defined by <em>script items</em>, which must be listed in the <strong>script</strong> instance variable of your <strong>Paradigm</strong> class. The script items are processed one by one in the order in which they appear in the instance variable <strong>script</strong>. A script item can be triggered by a <strong>time event</strong>, by a <strong>signal event</strong> generated by a graphical object, or by an external <strong>LSL marker event</strong>. You can also combine different trigger types. The script item is then triggered by whichever event comes first. A script item can be defined as:</p>
<p><code>ScriptItem(name='trial_start', time=10, actions=[info_text.activate])</code></p>
<p>In this example, the script item will call the method <strong>activate</strong> on the graphical object <strong>info_text</strong> at second 10 after the program start.</p>
<p>The name of the script item is sent as an event marker in the LSL stream <em>yaga</em> when the item is triggered. This allows recording programs to save the paradigm state together with the LSL data streams (see <a href="../integration_with_lsl/">Integration with LSL</a>).</p>
<p>Note that the execution of script items is synchronised to the screen refresh rate (often 60 Hz).</p>
<h3 id="actions">Actions<a class="headerlink" href="#actions" title="Permanent link">&para;</a></h3>
<p>The actions parameter of a <strong>ScriptItem</strong> expects a list of methods which are called when the action item is triggered. The available actions depend on the presentation object and are listed in <a href="./#supported-graphical-objects">Supported Graphical Objects</a> and <a href="./#auditory-objects">Auditory Objects</a>.</p>
<p>The actions must be specified as objects and not as method calls, i.e., without subsequent parentheses. This is to ensure that actions are executed when the script item is triggered and not at the program start when the initialisation method is executed.</p>
<p>Some actions accept parameters. You can specify parameters by using the <strong>partial function</strong> from the <strong>functools module</strong>. The <strong>partial function</strong> allows to fix arguments and generates a new function object. This new function object is then executed when the action item is triggered.</p>
<p>First import <strong>partial</strong>:</p>
<p><code>from functools import partial</code></p>
<p>Then use <strong>partial</strong> to create a new function object with a fixed set of parameters, e.g.:</p>
<p><code>ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)])</code></p>
<p>In this example, <strong>targets.setActiveTarget(1)</strong> is executed when the script item is triggered.</p>
<h3 id="time-triggers">Time Triggers<a class="headerlink" href="#time-triggers" title="Permanent link">&para;</a></h3>
<p>YAGA supports two types of time triggers: <strong>absolute time triggers</strong> and <strong>relative time triggers</strong>. A trigger specified with an absolute time is triggered at the specified time after the program start. A trigger specified with a relative time is triggered at the specified time relative to another script item.</p>
<p>An absolute time trigger is the default. For example, to trigger a script item 10s after the program start, write:</p>
<p><code>ScriptItem(name='trial_start', time=10, actions=[info_text.activate])</code></p>
<p>To specify a relative time trigger, set <em>time_type</em> to <em>“rel”</em> and provide the name of the reference event with <em>rel_name</em>. For example, to trigger a script item 5s to 10s after the last “trial_end” event, write:</p>
<p><code>ScriptItem(name='trial_start', time=np.random.uniform(5, 10), time_type='rel', rel_name='trial_end', actions=[info_text.activate\])]</code></p>
<h3 id="signal-triggers">Signal Triggers<a class="headerlink" href="#signal-triggers" title="Permanent link">&para;</a></h3>
<p>A script item can wait for trigger signals generated by graphical objects. To trigger a script item with a signal, set <em>wait_for_signal</em> to the respective signal. The possible trigger signals are listed in <a href="./#supported-graphical-objects">Supported Graphical Objects</a>. For example:</p>
<p><code>ScriptItem(name='trial_end', wait_for_signal=GO.Countdown.COUNTDOWN_FINISHED, actions=[])</code></p>
<h3 id="lsl-event-marker-triggers">LSL Event Marker Triggers<a class="headerlink" href="#lsl-event-marker-triggers" title="Permanent link">&para;</a></h3>
<p>A script item can be triggered by an external <em>LSL event marker</em> generated by other programs. To listen to an LSL event marker stream, call the method <strong>listenForLSLMarkers</strong> in the paradigm file. For example, to listen for markers in the first channel of the stream <em>streamA</em>:</p>
<p><code>self.listenForLSLMarkers("streamA", lsl_marker_channel=0)</code></p>
<p>The streams are expected to be event marker streams, i.e., they have an irregular sampling rate. The markers are usually variable-length ASCII strings.</p>
<p>After setting up an LSL event listener, you can trigger script items on LSL events by specifying the marker with the parameter <em>wait_for_lsl_marker</em>. For example:</p>
<p><code>ScriptItem(name='trial_end', wait_for_lsl_marker=”target_reached”, actions=[])</code></p>
<p>The data type of the specified marker must correspond to the data type of the LSL stream (usually a <em>string</em>).</p>
<h2 id="command-line-variables">Command Line Variables<a class="headerlink" href="#command-line-variables" title="Permanent link">&para;</a></h2>
<p>YAGA supports three general-purpose variables, which can be specified when you start YAGA.py (<em>var1</em>, <em>var2</em>, <em>var3</em>). For example:</p>
<p><code>python yaga.py --paradigm YOURPARADIGM --var1 someStringOrNumber</code></p>
<p>The general purpose variables are accessible in the paradigm file:</p>
<pre><code>class Paradigm(ParadigmBase):

    def __init__(self, paradigm_variables):

        var1 = paradigm_variables['var1']
</code></pre>
<p>Moreover, one can specify the subject code (<em>string</em>) and session number (<em>integer</em>) with the command line parameters <code>--subject</code> and <code>--session</code>, respectively. These parameters are accessible as <code>paradigm_variables['subject']</code> and <code>paradigm_variables['session']</code> in the paradigm file.</p>
<h2 id="graphical-objects">Graphical Objects<a class="headerlink" href="#graphical-objects" title="Permanent link">&para;</a></h2>
<p>Graphical objects are objects shown on the computer screen, such as text or feedback bars. They can be <a href="./#control-of-graphical-objects">controllable</a> with LSL streams, and can feature animations.</p>
<p>To use graphical objects, one needs to import the <strong>graphic_objects module</strong> first:</p>
<p><code>import yaga_modules.graphic_objects as GO</code></p>
<p>A graphical object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a text object:</p>
<p><code>text = self.registerObject(GO.Text('prepare for task'))</code></p>
<h3 id="base-methods">Base Methods<a class="headerlink" href="#base-methods" title="Permanent link">&para;</a></h3>
<p>All graphical objects support the following methods which can be specified as actions in a <strong>ScriptItem</strong>:</p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>activate</td>
<td>-</td>
<td>-</td>
<td>show object on screen</td>
</tr>
<tr>
<td>deactivate</td>
<td>-</td>
<td>-</td>
<td>hide object on screen</td>
</tr>
</tbody>
</table>
<p>The position, scale, angle, and color of graphical objects can be changed with the following methods:</p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updatePos</td>
<td>pos_x, pos_y, depth</td>
<td>double, double, integer</td>
<td>set x/y position and depth</td>
</tr>
<tr>
<td>updateScale</td>
<td>scale_x, scale_y</td>
<td>double, double</td>
<td>set x/y size</td>
</tr>
<tr>
<td>updateRot</td>
<td>angle</td>
<td>double</td>
<td>rotate object (in degrees)</td>
</tr>
<tr>
<td>updateColor</td>
<td>color</td>
<td>string or 3-tuple</td>
<td>set color</td>
</tr>
</tbody>
</table>
<h3 id="screen-coordinates">Screen Coordinates<a class="headerlink" href="#screen-coordinates" title="Permanent link">&para;</a></h3>
<p>The screen coordinates are independent of the monitor resolution. The centre of the screen corresponds to the x/y position 0. The bottom edge corresponds to a y position of -1. The top edge corresponds to an y position of 1. The coordinates of the left and right edges depend on the screen ratio. With a typical screen ratio of 16:9, the left and right edges have the x coordinate -1.78 and 1.78, respectively ((y<sub>top</sub> - y<sub>center</sub>) x 16/9).</p>
<h3 id="depth-of-objects">Depth of Objects<a class="headerlink" href="#depth-of-objects" title="Permanent link">&para;</a></h3>
<p>The depth parameter must be an integer value and specifies the depth position of objects. Objects with a smaller depth value are in front of objects with a higher depth value (the default depth is 0).</p>
<h3 id="colour-of-objects">Colour of Objects<a class="headerlink" href="#colour-of-objects" title="Permanent link">&para;</a></h3>
<p>Many objects allow changing their colour. The colour must be specified as an RGB tuple with values from (0, 0, 0) to (255, 255, 255) or as a colour name (<em>string</em>). The following color names are supported: <em>black, white, red, lime, blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy, gold, orange,</em> and <em>darkorange</em>.</p>
<h3 id="animated-objects">Animated Objects<a class="headerlink" href="#animated-objects" title="Permanent link">&para;</a></h3>
<p>Some graphical objects support animations. Animations can be started or stopped using an action (<strong>startAnimation</strong>, <strong>stopAnimation</strong>) in a <strong>ScriptItem</strong>. Furthermore, animations can generate signals which can be used as triggers for <strong>ScriptItems</strong> (e.g., trigger actions at the end of an animation).</p>
<h3 id="supported-graphical-objects">Supported Graphical Objects<a class="headerlink" href="#supported-graphical-objects" title="Permanent link">&para;</a></h3>
<p>Typical graphical elements used in neuroscience experiments are implemented. The Python classes representing these elements are described in the following.</p>
<h4 id="image-class">Image Class<a class="headerlink" href="#image-class" title="Permanent link">&para;</a></h4>
<p>Loads an image file from the hard disk and displays it on the computer screen. All common image formats are supported.</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>file</td>
<td>string</td>
<td>file name of image</td>
</tr>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
</tbody>
</table>
<h4 id="ball-class">Ball Class<a class="headerlink" href="#ball-class" title="Permanent link">&para;</a></h4>
<p>Displays a filled circle on the computer screen.</p>
<p><img alt="ball" src="../images/ball.png" /></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>fill color</td>
</tr>
</tbody>
</table>
<h4 id="box-class">Box Class<a class="headerlink" href="#box-class" title="Permanent link">&para;</a></h4>
<p>Displays a filled box on the computer screen.</p>
<p><img alt="box" src="../images/box.png" /></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>fill color</td>
</tr>
</tbody>
</table>
<h4 id="cross-class">Cross Class<a class="headerlink" href="#cross-class" title="Permanent link">&para;</a></h4>
<p>Displays a cross on the screen.</p>
<p><img alt="cross" src="../images/cross.png" /></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>line_width</td>
<td>double</td>
<td>cross line size</td>
</tr>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>cross color</td>
</tr>
</tbody>
</table>
<h4 id="text-class">Text Class<a class="headerlink" href="#text-class" title="Permanent link">&para;</a></h4>
<p>Displays a text box on the computer screen. Optionally, a value can be read from an LSL stream and displayed on the screen as a rounded number.</p>
<p><img alt="text" src="../images/text.png" /></p>
<p>To read a number from an LSL stream, call the method <em>controlStateWithLSLStream</em>. For example:</p>
<pre><code>text = self.registerObject(GO.Text())
text.controlStateWithLSLStream(“the-stream”, channels=[1])
</code></pre>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td>string</td>
<td>text to display</td>
</tr>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>text color</td>
</tr>
<tr>
<td>background_color</td>
<td>string or 3-tuple</td>
<td>text box background color</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>text box frame color</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateColor</td>
<td>color</td>
<td>string or 3-tuple</td>
<td>set text color</td>
</tr>
<tr>
<td>updateBackgroundColor</td>
<td>color</td>
<td>string or 3-tuple</td>
<td>set text box background color</td>
</tr>
<tr>
<td>updateFrameColor</td>
<td>color</td>
<td>string or 3-tuple</td>
<td>set text box frame color</td>
</tr>
<tr>
<td>updateText</td>
<td>text</td>
<td>string</td>
<td>set text</td>
</tr>
</tbody>
</table>
<h4 id="randomnumber-class">RandomNumber Class<a class="headerlink" href="#randomnumber-class" title="Permanent link">&para;</a></h4>
<p>Display a random number in a text box on the computer screen. The number is updated after each call of the method <strong>activate</strong> according to a discrete normal distribution.</p>
<p><img alt="random number" src="../images/rnd.png" /></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>interval</td>
<td>list of 2 integers</td>
<td>a random number is drawn from the specified closed interval</td>
</tr>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>text color</td>
</tr>
<tr>
<td>background_color</td>
<td>string or 3-tuple</td>
<td>text box background color; set to None to deactivate</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>text box frame color; set to None to deactivate</td>
</tr>
</tbody>
</table>
<h4 id="countdown-class">Countdown Class<a class="headerlink" href="#countdown-class" title="Permanent link">&para;</a></h4>
<p>An animated countdown is displayed in a text box on the computer screen. The countdown is restarted after each call of the method <strong>activate</strong>.</p>
<p><img alt="countdown" src="../images/countdown.png" /></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>counter_start</td>
<td>integer</td>
<td>initial value of the countdown</td>
</tr>
<tr>
<td>counter_stop</td>
<td>integer</td>
<td>final value of the countdown</td>
</tr>
<tr>
<td>counter_interval</td>
<td>double</td>
<td>interval time in seconds</td>
</tr>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>scale_x</td>
<td>double</td>
<td>horizontal size</td>
</tr>
<tr>
<td>scale_y</td>
<td>double</td>
<td>vertical size</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>color</td>
<td>string or 3-tuple</td>
<td>text color</td>
</tr>
<tr>
<td>background_color</td>
<td>string or 3-tuple</td>
<td>text box background color</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>text box frame color</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Countdown.COUNTDOWN_FINISHED</td>
<td>elicited at the end of the countdown</td>
</tr>
</tbody>
</table>
<h4 id="bar-class">Bar Class<a class="headerlink" href="#bar-class" title="Permanent link">&para;</a></h4>
<p>Displays a bar for 1D feedback on the screen. The fill level of the bar is controlled with a channel from an LSL stream. Optionally, a horizontal target line can be specified. The target line position can be fixed at object initialization, updated with a call of <strong>updateTargetValue</strong>, or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter <em>target_online_control</em>) or updated at discrete time points with the action <strong>updateTargetValueFromLSLStream</strong>.</p>
<p><img alt="bar" src="../images/bar.png" /></p>
<p>To set up the control of the fill level, call the method <strong>controlStateWithLSLStream</strong> and specify one control channel. For example:</p>
<pre><code>bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0))
bar.controlStateWithLSLStream(“the-stream”, channels=[0])
</code></pre>
<p>To optionally control the vertical target position continuously with the same LSL stream, set <em>target_online_control</em> to <em>true</em>, and specify a second control channel. For example:</p>
<pre><code>bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true))
bar.controlStateWithLSLStream(“the-stream”, channels=[0, 1])
</code></pre>
<p>The vertical target position can also be controlled with a separate LSL stream by using <strong>controlStateWithLSLStream<u>s</u></strong>. The second specified channel then refers to the second stream. For example:</p>
<pre><code>bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=true))
bar.controlStateWithLSLStream([“stream-A”, &quot;stream-B&quot;], channels=[0, 1])
</code></pre>
<p>Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action <strong>updateTargetValueFromLSLStream</strong> in the respective <strong>ScriptItem</strong> objects. Note that you still need to set up the control with <strong>controlStateWithLSLStream</strong> or <strong>controlStateWithLSLStreams</strong>.
For example:</p>
<pre><code>bar = self.registerObject(GO.Bar(pos_x=0, pos_y=0, target_online_control=false))
bar.controlStateWithLSLStream(“the-stream”, channels=[0, 1])

[...]

ScriptItem(name='update_bar', time=10, actions=[bar.updateTargetValueFromLSLStream])
</code></pre>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>bar_width</td>
<td>double</td>
<td>width of the bar</td>
</tr>
<tr>
<td>bar_height</td>
<td>double</td>
<td>height of the bar when fully raised</td>
</tr>
<tr>
<td>frame_width</td>
<td>double</td>
<td>thickness of the frame around the bar</td>
</tr>
<tr>
<td>target_width</td>
<td>double</td>
<td>width of the target line</td>
</tr>
<tr>
<td>target_height</td>
<td>double</td>
<td>height of the target line</td>
</tr>
<tr>
<td>bar_color</td>
<td>string or 3-tuple</td>
<td>color of the bar</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>color of the bar frame</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target line</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to an empty bar</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully filled bar</td>
</tr>
<tr>
<td>target_value</td>
<td>double</td>
<td>- target value or fill level (<em>low_value</em> &lt;= target &lt;= <em>high_value</em>) <br> - if set to <em>None</em>, no target will be displayed</td>
</tr>
<tr>
<td>target_online_control</td>
<td>bool</td>
<td>- if <em>true</em> control the vertical target position continuously with an LSL stream <br> - a second control channel for the target position must be specified when calling <strong>controlStateWithLSLStream</strong> or <strong>controlStateWithLSLStreams</strong> <br> - if <em>false</em>, the target position can be updated with the action <strong>updateTargetValueFromLSLStream</strong></td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>updateTargetValueFromLSLStream</td>
<td>-</td>
<td>-</td>
<td>- update the target value with the most recent value from an LSL stream <br> - it is necessary to call <strong>controlStateWithLSLStream(s)</strong> before</td>
</tr>
</tbody>
</table>
<h4 id="barwithramptarget-class">BarWithRampTarget Class<a class="headerlink" href="#barwithramptarget-class" title="Permanent link">&para;</a></h4>
<p>Displays a feedback [bar]](paradigm_scripting.md#bar-class) with a ramp animation of the target. The target will transit through the following phases:</p>
<ol>
<li>pre phase: target line is at the initial position</li>
<li>ramp up phase: target line moves upwards</li>
<li>hold phase: target line is at the hold position</li>
<li>ramp down phase: target line moves downwards</li>
<li>post phase: target line is back to the initial position</li>
</ol>
<p>An additional horizontal line indicating the final ramp target will be displayed (target information) if the target animation is configured to stop below the top of the bar.</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>bar_width</td>
<td>double</td>
<td>width of the bar</td>
</tr>
<tr>
<td>bar_height</td>
<td>double</td>
<td>height of the bar when fully raised</td>
</tr>
<tr>
<td>frame_width</td>
<td>double</td>
<td>thickness of the frame around the bar</td>
</tr>
<tr>
<td>target_width</td>
<td>double</td>
<td>width of the target line</td>
</tr>
<tr>
<td>target_height</td>
<td>double</td>
<td>height of the target line</td>
</tr>
<tr>
<td>bar_color</td>
<td>string or 3-tuple</td>
<td>color of the bar</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>color of the bar frame</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target line</td>
</tr>
<tr>
<td>target_info_color</td>
<td>string or 3-tuple</td>
<td>color of the target information</td>
</tr>
<tr>
<td>pre_phase_duration</td>
<td>double</td>
<td>time duration of the pre phase</td>
</tr>
<tr>
<td>ramp_up_phase_duration</td>
<td>double</td>
<td>time duration of the ramp up phase</td>
</tr>
<tr>
<td>hold_phase_duration</td>
<td>double</td>
<td>time duration of the hold phase</td>
</tr>
<tr>
<td>ramp_down_phase_duration</td>
<td>double</td>
<td>time duration of the ramp down phase</td>
</tr>
<tr>
<td>post_phase_duration</td>
<td>double</td>
<td>time duration of the post phase</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to a fully contracted bar</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully raised bar</td>
</tr>
<tr>
<td>start_value</td>
<td>double</td>
<td>the initial position of the target</td>
</tr>
<tr>
<td>ramp_value</td>
<td>double</td>
<td>the position of the target in the hold phase</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>startAnimation</td>
<td>-</td>
<td>-</td>
<td>start ramp animation</td>
</tr>
<tr>
<td>stopAnimation</td>
<td>-</td>
<td>-</td>
<td>stop ramp animation</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BarWithRampTarget.BAR_FINISHED</td>
<td>elicited after the end of the post phase</td>
</tr>
</tbody>
</table>
<h4 id="barwithsinustarget-class">BarWithSinusTarget Class<a class="headerlink" href="#barwithsinustarget-class" title="Permanent link">&para;</a></h4>
<p>Displays a feedback <a href="./#bar-class">bar</a> with a sinus oscillation animation of the target. The target will transit through the following phases:</p>
<ol>
<li>pre phase: target line is at the initial position</li>
<li>ramp up phase: target line moves upwards</li>
<li>sinus phase: target line oscillates up and down</li>
<li>ramp down phase: target line moves downwards</li>
<li>post phase: target line is back to the initial position</li>
</ol>
<p>An additional horizontal line indicating the oscillation center will be displayed (target information) if the oscillation center is configured to be below the top of the bar.</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>bar_width</td>
<td>double</td>
<td>width of the bar</td>
</tr>
<tr>
<td>bar_height</td>
<td>double</td>
<td>height of the bar when fully raised</td>
</tr>
<tr>
<td>frame_width</td>
<td>double</td>
<td>thickness of the frame around the bar</td>
</tr>
<tr>
<td>target_width</td>
<td>double</td>
<td>width of the target line</td>
</tr>
<tr>
<td>target_height</td>
<td>double</td>
<td>height of the target line</td>
</tr>
<tr>
<td>bar_color</td>
<td>string or 3-tuple</td>
<td>color of the bar</td>
</tr>
<tr>
<td>frame_color</td>
<td>string or 3-tuple</td>
<td>color of the bar frame</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target line</td>
</tr>
<tr>
<td>target_info_color</td>
<td>string or 3-tuple</td>
<td>color of the target information</td>
</tr>
<tr>
<td>pre_phase_duration</td>
<td>double</td>
<td>time duration of the pre phase</td>
</tr>
<tr>
<td>ramp_up_phase_duration</td>
<td>double</td>
<td>time duration of the ramp up phase</td>
</tr>
<tr>
<td>sinus_phase_duration</td>
<td>double</td>
<td>time duration of the oscillation phase</td>
</tr>
<tr>
<td>sinus_frequency</td>
<td>double</td>
<td>oscillation frequency in Hz</td>
</tr>
<tr>
<td>sinus_amplitude</td>
<td>double</td>
<td>oscillation amplitude</td>
</tr>
<tr>
<td>ramp_down_phase_duration</td>
<td>double</td>
<td>time duration of the ramp down phase</td>
</tr>
<tr>
<td>post_phase_duration</td>
<td>double</td>
<td>time duration of the post phase</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to a fully contracted bar</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully raised bar</td>
</tr>
<tr>
<td>start_value</td>
<td>double</td>
<td>the initial position of the target</td>
</tr>
<tr>
<td>ramp_value</td>
<td>double</td>
<td>the center position of the sinus oscillations</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>startAnimation</td>
<td>-</td>
<td>-</td>
<td>start ramp animation</td>
</tr>
<tr>
<td>stopAnimation</td>
<td>-</td>
<td>-</td>
<td>stop ramp animation</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BarWithSinusTarget.BAR_FINISHED</td>
<td>elicited after the end of the post phase</td>
</tr>
</tbody>
</table>
<h4 id="arrow-class">Arrow Class<a class="headerlink" href="#arrow-class" title="Permanent link">&para;</a></h4>
<p>Displays an arrow for 2D feedback on the computer screen. The endpoint of the arrow is controlled with two channels from an LSL stream. Optionally, a target can be visualised as a disk above the arrow's origin. The vertical target position can be fixed at object initialization, updated with a call of <strong>updateTargetValue</strong>, or controlled with an LSL stream. If the target is controlled with an LSL stream, the target position can be continuously updated (see parameter <em>target_online_control</em>) or updated at discrete time points with the action <strong>updateTargetValueFromLSLStream</strong>.</p>
<p><img alt="arrow" src="../images/arrow.png" /></p>
<p>To set up the control of the arrow’s endpoint, call the method <strong>controlStateWithLSLStream</strong> and specify the LSL stream and two control channels. For example:</p>
<pre><code>arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1])
</code></pre>
<p>To optionally control the vertical target position continuously with the same LSL stream, set <em>target_online_control</em> to <em>true</em>, and specify a third control channel. For example:</p>
<pre><code>arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])
</code></pre>
<p>The vertical target position can also be controlled with a separate LSL stream by using <strong>controlStateWithLSLStream<u>s</u></strong>. The third specified channel then refers to the second stream. For example:</p>
<pre><code>arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=true))
arrow.controlStateWithLSLStreams([“stream-A”, &quot;stream-B&quot;], channels=[0, 1, 0])
</code></pre>
<p>Instead of continuously updating the target position from an LSL stream, the target position can also be updated when a script item is triggered. This can be achieved by specifying the action <strong>updateTargetValueFromLSLStream</strong> in the respective <strong>ScriptItem</strong> objects. Note that you still need to set up the control with <strong>controlStateWithLSLStream</strong> or <strong>controlStateWithLSLStreams</strong>.
For example:</p>
<pre><code>arrow = self.registerObject(GO.Arrow(pos_x=0, pos_y=0, target_online_control=false))
arrow.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])

[...]

ScriptItem(name='update_arrow', time=10, actions=[arrow.updateTargetValueFromLSLStream])
</code></pre>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle of the arrow</td>
</tr>
<tr>
<td>arrow_length</td>
<td>double</td>
<td>length of the arrow when fully extended</td>
</tr>
<tr>
<td>line_width</td>
<td>double</td>
<td>width of the arrow</td>
</tr>
<tr>
<td>head_size</td>
<td>double</td>
<td>head size of the arrow</td>
</tr>
<tr>
<td>target_size</td>
<td>double</td>
<td>size of the target</td>
</tr>
<tr>
<td>arrow_color</td>
<td>string or 3-tuple</td>
<td>color of the arrow</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to a fully contracted arrow</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully extended arrow</td>
</tr>
<tr>
<td>target_value</td>
<td>double</td>
<td>- target value (vertical target position) <br> - if set to <em>None</em>, no target will be displayed</td>
</tr>
<tr>
<td>target_online_control</td>
<td>bool</td>
<td>- if <em>true</em>, control the vertical target position continuously with an LSL stream <br> - a third control channel for the target position must be specified when calling <strong>controlStateWithLSLStream</strong> or <strong>controlStateWithLSLStreams</strong> <br> - if <em>false</em>, the target position can be updated with the action <strong>updateTargetValueFromLSLStream</strong></td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>updateTargetValueFromLSLStream</td>
<td>-</td>
<td>-</td>
<td>- update the target value with the most recent value from an LSL stream <br> - it is necessary to call <strong>controlStateWithLSLStream(s)</strong>* before</td>
</tr>
</tbody>
</table>
<h4 id="arrowwithramptarget-class">ArrowWithRampTarget Class<a class="headerlink" href="#arrowwithramptarget-class" title="Permanent link">&para;</a></h4>
<p>Displays a feedback <a href="./#arrow-class">arrow</a> with a ramp animation of the target disk. The target will transit through the following phases:</p>
<ol>
<li>pre phase: target disk is at the initial position</li>
<li>ramp up phase: target disk moves upwards</li>
<li>hold phase: target disk is at the final position</li>
<li>ramp down phase: target disk moves downwards</li>
<li>post phase: target disk is back to the initial position</li>
</ol>
<p>An additional disk indicating the final ramp target position will be displayed (target information).</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>arrow_length</td>
<td>double</td>
<td>length of the arrow when fully extended</td>
</tr>
<tr>
<td>line_width</td>
<td>double</td>
<td>width of the arrow</td>
</tr>
<tr>
<td>head_size</td>
<td>double</td>
<td>head size of the arrow</td>
</tr>
<tr>
<td>target_size</td>
<td>double</td>
<td>size of the target</td>
</tr>
<tr>
<td>target_info_size</td>
<td>double</td>
<td>size of the target information</td>
</tr>
<tr>
<td>arrow_color</td>
<td>string or 3-tuple</td>
<td>color of the arrow</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target</td>
</tr>
<tr>
<td>target_info_color</td>
<td>string or 3-tuple</td>
<td>color of the target information</td>
</tr>
<tr>
<td>pre_phase_duration</td>
<td>double</td>
<td>time duration of the pre phase</td>
</tr>
<tr>
<td>ramp_up_phase_duration</td>
<td>double</td>
<td>time duration of the ramp up phase</td>
</tr>
<tr>
<td>hold_phase_duration</td>
<td>double</td>
<td>time duration of the hold phase</td>
</tr>
<tr>
<td>ramp_down_phase_duration</td>
<td>double</td>
<td>time duration of the ramp down phase</td>
</tr>
<tr>
<td>post_phase_duration</td>
<td>double</td>
<td>time duration of the post phase</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to a fully contracted arrow</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully extended arrow</td>
</tr>
<tr>
<td>start_value</td>
<td>double</td>
<td>the initial position of the target</td>
</tr>
<tr>
<td>ramp_value</td>
<td>double</td>
<td>- the center position of the sinus oscillation <br> - when this value is lower than the <em>high_value</em>, an additional hold target will be displayed</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>startAnimation</td>
<td>-</td>
<td>-</td>
<td>start ramp animation</td>
</tr>
<tr>
<td>stopAnimation</td>
<td>-</td>
<td>-</td>
<td>stop ramp animation</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrowWithRampTarget.BAR_ARROW_FINISHED</td>
<td>elicited after the end of the post phase</td>
</tr>
</tbody>
</table>
<h4 id="arrowwithsinustarget-class">ArrowWithSinusTarget Class<a class="headerlink" href="#arrowwithsinustarget-class" title="Permanent link">&para;</a></h4>
<p>Displays a feedback <a href="./#arrow-class">arrow Class</a> with a ramp animation of the target disk. The target will transit through the following phases:</p>
<ol>
<li>pre phase: target disk is at the initial position</li>
<li>ramp up phase: target disk moves upwards</li>
<li>sinus phase: target disk is oscillating up &amp; down</li>
<li>ramp down phase: target disk moves downwards</li>
<li>post phase: target disk is back to the initial position</li>
</ol>
<p>An additional disk indicating the position of the oscillation centre will be displayed (target information).</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>angle</td>
<td>double</td>
<td>rotation angle</td>
</tr>
<tr>
<td>arrow_length</td>
<td>double</td>
<td>length of the arrow when fully extended</td>
</tr>
<tr>
<td>line_width</td>
<td>double</td>
<td>width of the arrow</td>
</tr>
<tr>
<td>head_size</td>
<td>double</td>
<td>head size of the arrow</td>
</tr>
<tr>
<td>target_size</td>
<td>double</td>
<td>size of the target</td>
</tr>
<tr>
<td>target_info_size</td>
<td>double</td>
<td>size of the target information</td>
</tr>
<tr>
<td>arrow_color</td>
<td>string or 3-tuple</td>
<td>color of the arrow</td>
</tr>
<tr>
<td>target_color</td>
<td>string or 3-tuple</td>
<td>color of the target</td>
</tr>
<tr>
<td>target_info_color</td>
<td>string or 3-tuple</td>
<td>color of the target information</td>
</tr>
<tr>
<td>pre_phase_duration</td>
<td>double</td>
<td>time duration of the pre phase</td>
</tr>
<tr>
<td>ramp_up_phase_duration</td>
<td>double</td>
<td>time duration of the ramp up phase</td>
</tr>
<tr>
<td>sinus_phase_duration</td>
<td>double</td>
<td>time duration of the oscillation phase</td>
</tr>
<tr>
<td>sinus_frequency</td>
<td>double</td>
<td>oscillation frequency in Hz</td>
</tr>
<tr>
<td>sinus_amplitude</td>
<td>double</td>
<td>oscillation amplitude</td>
</tr>
<tr>
<td>ramp_down_phase_duration</td>
<td>double</td>
<td>time duration of the ramp down phase</td>
</tr>
<tr>
<td>post_phase_duration</td>
<td>double</td>
<td>time duration of the post phase</td>
</tr>
<tr>
<td>low_value</td>
<td>double</td>
<td>LSL value corresponding to a fully contracted arrow</td>
</tr>
<tr>
<td>high_value</td>
<td>double</td>
<td>LSL value corresponding to a fully extended arrow</td>
</tr>
<tr>
<td>start_value</td>
<td>double</td>
<td>the initial position of the target</td>
</tr>
<tr>
<td>ramp_value</td>
<td>double</td>
<td>- the center position of the sinus oscillation <br> - when this value is lower than the <em>high_value</em>, an additional hold target will be displayed</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>updateTargetValue</td>
<td>target_value</td>
<td>double</td>
<td>update the target value</td>
</tr>
<tr>
<td>startAnimation</td>
<td>-</td>
<td>-</td>
<td>start ramp animation</td>
</tr>
<tr>
<td>stopAnimation</td>
<td>-</td>
<td>-</td>
<td>stop ramp animation</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrowWithSinusTarget.BAR_ARROW_FINISHED</td>
<td>elicited after the end of the post phase</td>
</tr>
</tbody>
</table>
<h4 id="spikevis-class">SpikeVis Class<a class="headerlink" href="#spikevis-class" title="Permanent link">&para;</a></h4>
<p>Visualise discrete events, such as spikes, with flashing feedback disks. A SpikeVis object can be used as a feedback element for, e.g., the onset and termination of spike trains.</p>
<p><img alt="spikevis" src="../images/spikevis.png" /></p>
<p>SpikeVis supports multiple feedback disks and must have as many LSL control channels as feedback disks. The LSL control channels are expected to provide 0/1 values. To set up the control, call the method <strong>controlStateWithLSLStream</strong>. For example:</p>
<pre><code>spikes = self.registerObject(GO.SpikeVis(pos_x=0, pos_y=0, number_of_units=3))
spikes.controlStateWithLSLStream(“the-stream”, channels=[0, 1, 2])
</code></pre>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>number_of_units</td>
<td>integer</td>
<td>number of feedback disks; must correspond to the number of LSL control channels</td>
</tr>
<tr>
<td>size</td>
<td>double</td>
<td>size of a feedback disk</td>
</tr>
<tr>
<td>spacing</td>
<td>double</td>
<td>distance between feedback disks</td>
</tr>
<tr>
<td>flash_duration</td>
<td>double</td>
<td>time in seconds a feedback disk flashes (activates) when a “1” is read from the corresponding LSL control channel</td>
</tr>
<tr>
<td>active_color</td>
<td>string or 3-tuple</td>
<td>color of the feedback disk when inactive</td>
</tr>
<tr>
<td>inactive_color</td>
<td>string or 3-tuple</td>
<td>color of the feedback disk when it is active</td>
</tr>
</tbody>
</table>
<h4 id="reachtargets-class">ReachTargets Class<a class="headerlink" href="#reachtargets-class" title="Permanent link">&para;</a></h4>
<p>Graphical object to implement target reaching experiments. It displays one or more disk targets which must be reached and held with a 2D cursor. The targets will be arranged in a circle around the centre. The cursor is controlled with 2 LSL channels.</p>
<p><img alt="target reach" src="../images/targetreach.png" /></p>
<p>To set up the control, call the method <strong>controlStateWithLSLStream</strong>. For example:</p>
<pre><code>targetreaching = self.registerObject(GO.ReachTargets(pos_x=0, pos_y=0, number_of_targets=3))
targetreaching.controlStateWithLSLStream(“the-stream”, channels=[0,1])
</code></pre>
<p>An optional start target can be specified. Such a start target will be placed in the centre and must be reached before the actual target.</p>
<p>The cursor must stay within the correct target area for a certain period (dwell time) to generate a target-reached signal. This target-reached signal can then be used to trigger a script item.</p>
<p>To activate the ReachTargets object at second 10 and set the active (current) target to target 1, create a script item such as:</p>
<p><code>ScriptItem(name='trial_start', time=10, actions=[targets.activate, partial(targets.setActiveTarget, 1)])</code></p>
<p>To end the trial when the target reached signal is generated or a 30s timeout occurs, create a script item such as:</p>
<p><code>ScriptItem(name='trial_end', time=30, time_type='rel', rel_name='trial_start', wait_for_signal=GO.ReachTargets.TARGET_REACHED, actions=[targets.deactivate])</code></p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pox_x</td>
<td>double</td>
<td>horizontal position</td>
</tr>
<tr>
<td>pos_y</td>
<td>double</td>
<td>vertical position</td>
</tr>
<tr>
<td>depth</td>
<td>integer</td>
<td>depth position</td>
</tr>
<tr>
<td>radius</td>
<td>double</td>
<td>radius of the targets around the center</td>
</tr>
<tr>
<td>number_of_targets</td>
<td>integer</td>
<td>number of targets</td>
</tr>
<tr>
<td>dwell_time</td>
<td>double</td>
<td>dwell or hold time of targets</td>
</tr>
<tr>
<td>start_target</td>
<td>bool</td>
<td>show a start target</td>
</tr>
<tr>
<td>target_rotation</td>
<td>double</td>
<td>rotate targets (in degrees)</td>
</tr>
<tr>
<td>target_size</td>
<td>double</td>
<td>target size</td>
</tr>
<tr>
<td>cursor_size</td>
<td>double</td>
<td>cursor size</td>
</tr>
<tr>
<td>target_active_color</td>
<td>string or 3-tuple</td>
<td>color of the active (current) target disk</td>
</tr>
<tr>
<td>target_inactive_color</td>
<td>string or 3-tuple</td>
<td>color of the inactivate target disks</td>
</tr>
<tr>
<td>target_reached_color</td>
<td>string or 3-tuple</td>
<td>color of the target disk when the cursor is within the target area</td>
</tr>
<tr>
<td>cursor_color</td>
<td>string or 3-tuple</td>
<td>color of the cursor</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>setActiveTarget</td>
<td>selected_target_idx</td>
<td>integer</td>
<td>index of the active (current) target</td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Trigger Signals:</em></p>
<table>
<thead>
<tr>
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReachTargets.START_TARGET_REACHED</td>
<td>optional start target has been reached</td>
</tr>
<tr>
<td>ReachTargets.TARGET_REACHED</td>
<td>active (current) target has been reached</td>
</tr>
</tbody>
</table>
<h2 id="auditory-objects">Auditory Objects<a class="headerlink" href="#auditory-objects" title="Permanent link">&para;</a></h2>
<p>Auditory objects generate sounds. They can be <a href="./#control-of-auditory-objects">controllable</a> with LSL streams.</p>
<p>To use auditory objects, one needs to import the <strong>audio_objects module</strong> first:</p>
<p><code>import yaga_modules.audio_objects as AO</code></p>
<p>An auditory object must be created in the initialisation method of the paradigm file and registered to YAGA. For example, to create a beep object:</p>
<p><code>beep = self.registerObject(AO.Beep())</code></p>
<p>The Python classes representing the auditory objects are described in the following.</p>
<h3 id="beep-class">Beep Class<a class="headerlink" href="#beep-class" title="Permanent link">&para;</a></h3>
<p>Generates a beep sound, e.g., to attract the attention of the subject.</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beep_frequency</td>
<td>double</td>
<td>frequency of the beep in Hz</td>
</tr>
<tr>
<td>beep_amplitude</td>
<td>double</td>
<td>sound level</td>
</tr>
<tr>
<td>beep_duration</td>
<td>double</td>
<td>duration of a beep in seconds</td>
</tr>
<tr>
<td>beep_channels</td>
<td>string</td>
<td>output channels: “both”, “left”, or “right”</td>
</tr>
<tr>
<td>delay</td>
<td>double</td>
<td>- delay the presentation of the beep <br> - use a delay of 0.2s or more to <strong>minimise jitter</strong></td>
</tr>
</tbody>
</table>
<p><em>ScriptItem Actions:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beep</td>
<td>-</td>
<td>-</td>
<td>generate beep</td>
</tr>
</tbody>
</table>
<h3 id="spikesound-class">SpikeSound Class<a class="headerlink" href="#spikesound-class" title="Permanent link">&para;</a></h3>
<p>Generate a feedback signal for discrete events like spikes. SpikeSound supports multiple event or spike signals which can be associated with a specific sound frequency or output channel. Optionally, the sound frequencies can be dynamically modulated by the instantaneous firing rates. The events are read from an LSL stream which is expected to provide 0/1 values. To set up the LSL control call the method <strong>controlStateWithLSLStream</strong>. For example, to generate sounds for two spike signals using different sound frequencies and output channels:</p>
<pre><code>spikes = self.registerObject(AO.SpikeSound(beep_frequencies=\[800, 2000\], beep_channels=\['left', 'right'\]))
spikes.controlStateWithLSLStream(“the-stream”, channels=\[0, 1\])
</code></pre>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beep_frequencies</td>
<td>list of doubles</td>
<td>- list of frequencies in Hz <br> - must have the same length as number of LSL channels <br> - values must be between 100 Hz and 10 kHz</td>
</tr>
<tr>
<td>beep_channels</td>
<td>list of strings</td>
<td>- list of output channels (<em>“both”</em>, <em>“left”</em>, or <em>“right”</em>) <br> - must have the same length as number of LSL channels</td>
</tr>
<tr>
<td>beep_duration</td>
<td>double</td>
<td>duration of each spike sound</td>
</tr>
<tr>
<td>downsample</td>
<td>integer</td>
<td>downsample factor; generate a spike sound for every x^th^ spike</td>
</tr>
<tr>
<td>dynamic_frq</td>
<td>bool</td>
<td>if <em>true</em>, modulate the sound frequency by the instantaneous firing rate</td>
</tr>
<tr>
<td>dynamic_frq_factor</td>
<td>integer</td>
<td>the final sound frequency is the base frequency (from <em>beep_frequencies</em>) plus the instantaneous firing rate multiplied by this factor</td>
</tr>
<tr>
<td>dynamic_max_frq</td>
<td>double</td>
<td>limit the smoothed instantaneous firing rate to this frequency</td>
</tr>
<tr>
<td>dynamic_mov_avg</td>
<td>integer</td>
<td>- calculate the instantaneous firing rate as the inverse of the interspike interval smoothed with a moving average window of length <em>dynamic_mov_avg</em> <br> - set to <em>None</em> if exponential smoothing is used</td>
</tr>
<tr>
<td>dynamic_exp_avg_alpha</td>
<td>double</td>
<td>- calculate the instantaneous firing rate as the inversive of the interspike interval smoothed with exponential smoothing using a smoothing factor of <em>dynamic_exp_avg_alpha</em> <br> - set to <em>None</em> if the moving average is used</td>
</tr>
</tbody>
</table>
<h2 id="online-control-of-objects-with-lsl-streams">Online Control of Objects with LSL streams<a class="headerlink" href="#online-control-of-objects-with-lsl-streams" title="Permanent link">&para;</a></h2>
<p>Parameters of graphical and auditory objects can be controlled with LSL streams. The LSL streams can be read directly or processed online (scaling, filtering, etc.). The parameter updates are synchronous to the screen refresh rate.</p>
<h3 id="control-of-graphical-objects">Control of Graphical Objects<a class="headerlink" href="#control-of-graphical-objects" title="Permanent link">&para;</a></h3>
<p>The position, scale, colour or state of graphical objects can be controlled by one or more LSL streams. For that, call the respective control method listed below.</p>
<p><em>Methods for controlling a property with a single LSL stream:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>controlPosWithLSLStream</td>
<td>lsl_stream_name, channels, aggregation_mode</td>
<td>string, list of integers, string</td>
<td>control the x/y position of an object with two channels from a single LSL stream</td>
</tr>
<tr>
<td>controlScaleWithLSLStream</td>
<td>lsl_stream_name, channels, aggregation_mode</td>
<td>string, list of integers, string</td>
<td>control the x/y size of an object with two channels from a single LSL stream</td>
</tr>
<tr>
<td>controlColorWithLSLStream</td>
<td>lsl_stream_name, channel, aggregation_mode, <br> neg_color, pos_color, neutral_color</td>
<td>string, integer, string, <br> string, string, string</td>
<td>- interpolate between colors using one channel from a single LSL stream: <br> &nbsp;&nbsp;&nbsp;&nbsp; when the value of the LSL channel is in the interval [-1, 0): interpolate between the negative and neutral color <br> &nbsp;&nbsp;&nbsp;&nbsp; when the value of the LSL channel is in the interval [0, 1]: interpolate between the neutral and positive color <br> - colors must be specified by their name (<em>string</em>)</td>
</tr>
<tr>
<td>controlStateWithLSLStream</td>
<td>lsl_stream_name, channels, aggregation_mode</td>
<td>string, list of integers, string</td>
<td>state updates are specific to the <a href="./#supported-graphical-objects">graphical object</a></td>
</tr>
</tbody>
</table>
<ul>
<li>the <em>channels</em> parameter of <strong>controlPosWithLSLStream</strong> and <strong>controlScaleWithLSLStream</strong> must be a list comprising two channel indices</li>
<li>the <em>channel</em> parameter of <strong>controlColorWithLSLStream</strong> must be a channel index</li>
<li>the <em>channels</em> parameter of <strong>controlStateWithLSLStream</strong> must be a list with one or more channel indices (the number of channels depends on the actual graphical object)</li>
<li>for an explanation of the <em>aggregation_mode</em> parameter see <a href="./#aggregation-mode">Aggregation Mode</a></li>
<li><strong>note that channel indexing starts with a 0 in Python</strong></li>
</ul>
<p><em>Methods for controlling a property with multiple LSL stream:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>controlPosWithLSLStreams</td>
<td>lsl_stream_names, channels, aggregation_mode</td>
<td>list of strings, list of integers, string</td>
<td>control the x/y position of an object with two channels from two separate LSL streams</td>
</tr>
<tr>
<td>controlScaleWithLSLStreams</td>
<td>lsl_stream_names, channels, aggregation_mode</td>
<td>list of strings, list of integers, string</td>
<td>controls the x/y size of an object with two channels from two separate LSL streams</td>
</tr>
<tr>
<td>controlStateWithLSLStreams</td>
<td>lsl_stream_names, channels, aggregation_mode</td>
<td>list of strings, list of integers, string</td>
<td>currently only supported by <a href="./#bar-class">Bar Class</a> and <a href="./#arrow-class">Arrow Class</a></td>
</tr>
</tbody>
</table>
<h3 id="control-of-auditory-objects">Control of Auditory Objects<a class="headerlink" href="#control-of-auditory-objects" title="Permanent link">&para;</a></h3>
<p>Auditory objects support the following methods to set up LSL control.</p>
<p><em>Methods for controlling a property with one or more LSL stream:</em></p>
<table>
<thead>
<tr>
<th>method</th>
<th>parameters</th>
<th>value types</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>controlWithLSLStream</td>
<td>stream name, channels, aggregation_mode</td>
<td>string, list of integers, string</td>
<td>currently only supported by <a href="./#spikesound-class">SpikeSound Class</a></td>
</tr>
<tr>
<td>controlWithLSLStreams</td>
<td>stream names, channels, aggregation_mode</td>
<td>list of string, list of integers, string</td>
<td>not yet supported by any auditory object</td>
</tr>
</tbody>
</table>
<h3 id="aggregation-mode">Aggregation Mode<a class="headerlink" href="#aggregation-mode" title="Permanent link">&para;</a></h3>
<p>The LSL streams used to control the parameters of graphical or auditory objects are read and processed just before a screen refresh. All updates are therefore synchronised with the screen refresh rate, which is often 60 Hz.</p>
<ul>
<li>when the sampling frequency of an LSL stream is <strong>lower</strong> than the screen refresh rate, the LSL stream is <strong>upsampled</strong> to the screen frequency using a <em>sample &amp; hold strategy</em></li>
<li>when the sampling frequency of an LSL stream is <strong>higher</strong> than the screen frequency, the LSL stream is <strong>downsampled</strong> strategy specified by <em>aggregation_mode</em> is used</li>
</ul>
<p>The following sample aggregation strategies are supported:</p>
<table>
<thead>
<tr>
<th>aggregation mode value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>last (default)</td>
<td>the most recent LSL sample is used, the rest is discarded</td>
</tr>
<tr>
<td>sum</td>
<td>the LSL samples since the last read-out are summed up</td>
</tr>
<tr>
<td>mean</td>
<td>the LSL samples since the last read-out are averaged</td>
</tr>
</tbody>
</table>
<h3 id="signal-processing">Signal Processing<a class="headerlink" href="#signal-processing" title="Permanent link">&para;</a></h3>
<p>LSL streams can be processed when used to control parameters of graphical or auditory objects. The YAGA signal processing methods are applied to the <em>original</em> LSL stream, i.e., before any re-sampling to the screen refresh rate (see <a href="./#aggregation-mode">Aggregation Mode</a>).</p>
<p>To use signal processing on LSL streams, import the <strong>signal_processing module</strong>:</p>
<p><code>import yaga_modules.signal_processing as SP</code></p>
<p>Signal processing objects can be added to the signal processing pipeline by calling the method <strong>addSignalProcessingToLSLStream</strong>. In the following example, a feedback bar is set to be controlled by an LSL stream and the LSL stream is filtered with a Butterworth low-pass filter and scaled:</p>
<pre><code>bar = self.registerObject(GO.Bar())
bar.controlStateWithLSLStream('the-stream, channels=[10])

butter = SP.ButterFilter(4, 5)
scaler = SP.Scaler(scale=2)

bar.addSignalProcessingToLSLStream(butter, channels=[10])
bar.addSignalProcessingToLSLStream(scaler, channels=[10])
</code></pre>
<p>The first parameter of <strong>addSignalProcessingToLSLStream</strong> is the signal processing object. The second parameter is the channel list. The number of supported channels depends on the concrete signal processing object.</p>
<p><strong>Important note:</strong> Make sure that signal processing objects which have a state (e.g., ButterFilter) exist only in one signal processing pipeline. If you need the same signal processing method applied to another LSL stream, create a new signal processing object.</p>
<p>The following signal processing objects are supported by YAGA.</p>
<h4 id="constant">Constant<a class="headerlink" href="#constant" title="Permanent link">&para;</a></h4>
<p>Set channels to a constant value.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>double</td>
<td>set signals to the given value</td>
</tr>
</tbody>
</table>
<h4 id="copychannel">CopyChannel<a class="headerlink" href="#copychannel" title="Permanent link">&para;</a></h4>
<p>Copy values from one channel to another channel.</p>
<p>Number of supported channels: two or more</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel_in</td>
<td>integer</td>
<td>index of the source channel</td>
</tr>
<tr>
<td>channel_out</td>
<td>integer</td>
<td>index of the destination channel</td>
</tr>
</tbody>
</table>
<h4 id="butterfilter">ButterFilter<a class="headerlink" href="#butterfilter" title="Permanent link">&para;</a></h4>
<p>Filters stream with a Butterworth filter.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: Yes</p>
<p>Stateful: Yes</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>integer</td>
<td>order of the filter</td>
</tr>
<tr>
<td>cutoff_frqs</td>
<td>double or list of doubles</td>
<td>critical frequency or frequencies: <br> &nbsp;&nbsp;&nbsp;&nbsp; low/highpass: a scalar <br> &nbsp;&nbsp;&nbsp;&nbsp; bandpass/stop: a 2-element list</td>
</tr>
<tr>
<td>filter_type</td>
<td>string</td>
<td>filter type, possible values: <em>lowpass</em>, <em>highpass</em>, <em>bandpass</em>, <em>bandstop</em></td>
</tr>
</tbody>
</table>
<h4 id="angle">Angle<a class="headerlink" href="#angle" title="Permanent link">&para;</a></h4>
<p>Calculates the angle in radians between the x-axis and the point given by (x,y). The first channel represents the x-coordinate, and the second channel represents the y-coordinate.</p>
<p>Number of supported channels: two</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<h4 id="integrate">Integrate<a class="headerlink" href="#integrate" title="Permanent link">&para;</a></h4>
<p>Integration over samples.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: yes</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>factor</td>
<td>double</td>
<td>multiply samples by a factor before integration</td>
</tr>
</tbody>
</table>
<h4 id="diff">Diff<a class="headerlink" href="#diff" title="Permanent link">&para;</a></h4>
<p>Calculates the difference between two consecutive samples.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: yes</p>
<h4 id="sum">Sum<a class="headerlink" href="#sum" title="Permanent link">&para;</a></h4>
<p>Calculates the sum over channels.</p>
<p>Number of supported channels: two or more</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<h4 id="mean">Mean<a class="headerlink" href="#mean" title="Permanent link">&para;</a></h4>
<p>Calculates the average over channels.</p>
<p>Number of supported channels: two or more</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<h4 id="stddev">StdDev<a class="headerlink" href="#stddev" title="Permanent link">&para;</a></h4>
<p>Calculates the standard deviation over channels.</p>
<p>Number of supported channels: two or more</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<h4 id="scaler">Scaler<a class="headerlink" href="#scaler" title="Permanent link">&para;</a></h4>
<p>Multiplies channels by a scaling factor and adds offsets before and after scaling.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>scale</td>
<td>double</td>
<td>scale samples by this factor</td>
</tr>
<tr>
<td>pre_offset</td>
<td>double</td>
<td>add <em>pre_offset</em> before scaling</td>
</tr>
<tr>
<td>post_offset</td>
<td>double</td>
<td>add <em>post_offset</em> after scaling</td>
</tr>
</tbody>
</table>
<h4 id="linearmap">LinearMap<a class="headerlink" href="#linearmap" title="Permanent link">&para;</a></h4>
<p>Linearly maps signals from the interval [<em>in_val1</em>, <em>in_val2</em>] to the interval [<em>out_val1</em>, <em>out_val2</em>].</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
</tr>
</thead>
<tbody>
<tr>
<td>in_val1</td>
<td>double</td>
</tr>
<tr>
<td>in_val2</td>
<td>double</td>
</tr>
<tr>
<td>out_val1</td>
<td>double</td>
</tr>
<tr>
<td>out_val2</td>
<td>double</td>
</tr>
</tbody>
</table>
<h4 id="limit">Limit<a class="headerlink" href="#limit" title="Permanent link">&para;</a></h4>
<p>Limit signals to minimum and maximum values.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_val</td>
<td>double</td>
<td>minimum value</td>
</tr>
<tr>
<td>max_val</td>
<td>double</td>
<td>maximum value</td>
</tr>
</tbody>
</table>
<h4 id="abs">Abs<a class="headerlink" href="#abs" title="Permanent link">&para;</a></h4>
<p>Calculates the absolute value.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<h4 id="power">Power<a class="headerlink" href="#power" title="Permanent link">&para;</a></h4>
<p>Raises signals to the given power.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>exponent</td>
<td>double</td>
<td>exponent (power)</td>
</tr>
</tbody>
</table>
<h4 id="euclidnorm">EuclidNorm<a class="headerlink" href="#euclidnorm" title="Permanent link">&para;</a></h4>
<p>Calculate the Euclidean norm over channels.</p>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: no</p>
<p>Stateful: no</p>
<h4 id="maxeuclidnormalizationxdf">MaxEuclidNormalizationXDF<a class="headerlink" href="#maxeuclidnormalizationxdf" title="Permanent link">&para;</a></h4>
<p>Normalise channels by the maximum Euclidean norm found from the data channels in the specified XDF file (e.g., force normalisation).</p>
<p>Find maximum:</p>
<ol>
<li>load the XDF file</li>
<li>apply a median window filter to the selected channels of the data stream</li>
<li>subtract a common or channel-specific offset</li>
<li>calculate the 2-norm over all selected channels</li>
<li>find the maximum norm value over all trials</li>
</ol>
<p>Online processing:</p>
<ol>
<li>subtract offset from signals</li>
<li>divide by the found maximum norm</li>
</ol>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: no</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xdf_file</td>
<td>string</td>
<td>XDF file to load</td>
</tr>
<tr>
<td>data_stream_name</td>
<td>string</td>
<td>name of data stream over which the Euclidean norm is calculated (e.g., 2D force data)</td>
</tr>
<tr>
<td>marker_stream_name</td>
<td>string</td>
<td>name of the event stream</td>
</tr>
<tr>
<td>start_marker</td>
<td>string</td>
<td>name of a trial start event</td>
</tr>
<tr>
<td>data_stream_channels</td>
<td>list of integers</td>
<td>channel indices of the data stream over which the Euclidean norm is calculated (if None, use all channels)</td>
</tr>
<tr>
<td>offset</td>
<td>double or list of double</td>
<td>- subtract an offset value before calculating the Euclidean norm <br> - to specify channel-specific offsets, specify offsets as a list with one offset value per channel <br> - set to <em>None</em> to subtract the minimum of each channel</td>
</tr>
<tr>
<td>filter_window_length</td>
<td>integer</td>
<td>filter data stream with a median filter using the specified window size in samples (must be odd)</td>
</tr>
</tbody>
</table>
<h4 id="maxavgpowernormalizationxdf">MaxAvgPowerNormalizationXDF<a class="headerlink" href="#maxavgpowernormalizationxdf" title="Permanent link">&para;</a></h4>
<p>Normalise channels by the maximum power found from the data channels in the specified XDF file (e.g., EMG power normalisation).</p>
<p>Find maximum:</p>
<ol>
<li>load the XDF file</li>
<li>apply a Butterworth bandpass filter to the selected channels of the data stream (pre-filter)</li>
<li>calculate the signal power of all selected channels</li>
<li>apply a moving average filter (post-filter)</li>
<li>calculate the median signal power over all selected channels</li>
<li>find the 90% percentile of the power over all trials</li>
</ol>
<p>Online processing:</p>
<ol>
<li>apply the pre-filter (bandpass)</li>
<li>calculate the signal power</li>
<li>apply the post-filter (moving average)</li>
<li>calculate the median over channels</li>
<li>divide signals by found 90% percentile of the power</li>
</ol>
<p>Number of supported channels: one or more</p>
<p>Operates channel-wise: yes</p>
<p>Stateful: yes</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xdf_file</td>
<td>string</td>
<td>XDF file to load</td>
</tr>
<tr>
<td>data_stream_name</td>
<td>string</td>
<td>name of data stream over which the Euclidean norm is calculated (e.g., 2D force data)</td>
</tr>
<tr>
<td>marker_stream_name</td>
<td>string</td>
<td>name of the event stream</td>
</tr>
<tr>
<td>start_marker</td>
<td>string</td>
<td>name of a trial start event</td>
</tr>
<tr>
<td>end_marker</td>
<td>string</td>
<td>name of a trial end event</td>
</tr>
<tr>
<td>data_stream_channels</td>
<td>list of integers</td>
<td>channel indices of the data stream over which the Euclidean norm is calculated (if <em>None</em>, use all channels)</td>
</tr>
<tr>
<td>prefilter_order</td>
<td></td>
<td>Butterworth bandpass filter order</td>
</tr>
<tr>
<td>prefilter_cutoff_frqs</td>
<td></td>
<td>Butterworth bandpass cutoff frequencies</td>
</tr>
<tr>
<td>postfilter_win_length</td>
<td></td>
<td>- apply a moving average filter with the specified windows length in samples <br> - set to 1 to deactivate filter</td>
</tr>
</tbody>
</table>
<h4 id="flappybirdcontroller">FlappyBirdController<a class="headerlink" href="#flappybirdcontroller" title="Permanent link">&para;</a></h4>
<p>Implements a Flappy Bird style 2D control with discrete events like spikes. As input, a 1D signal comprising 0/1 values is expected (e.g., spiking activity). The generated output is a 2D position signal, which can be used to control the position of other graphical objects.</p>
<p>The control works as follows:</p>
<ul>
<li>an input activity increases the position on the currently controlled axis</li>
<li>a short pause in the input activity switches the control between the x and y axis</li>
<li>the x and y positions decrease at a constant velocity</li>
</ul>
<p>Note: The signal processing object expects 2 channels, but only the activity in the first channel is evaluated. The channel values will be replaced by the calculated x/y position.</p>
<p>Number of supported channels: two</p>
<p>Operates channel-wise: no</p>
<p>Stateful: yes</p>
<p><em>Object Initialisation Parameters:</em></p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>value type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pos_increment</td>
<td>double</td>
<td>each discrete event (spike) increases the position on the currently controlled axis by this value</td>
</tr>
<tr>
<td>negative_vel</td>
<td>double</td>
<td>decrease the position on both axes by this velocity; however, recent spiking activity prevents the currently controlled axis from this change</td>
</tr>
<tr>
<td>switch_interval</td>
<td>double</td>
<td>minimum pause interval to switch between x and y axis</td>
</tr>
<tr>
<td>x_max</td>
<td>double</td>
<td>limit x position to this value</td>
</tr>
<tr>
<td>y_max</td>
<td>double</td>
<td>limit y position to this value</td>
</tr>
</tbody>
</table>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../installation/" class="btn btn-neutral float-left" title="Installation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../integration_with_lsl/" class="btn btn-neutral float-right" title="Integration with Lab Streaming Layer (LSL)">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/neurofreiburg/yaga" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../installation/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../integration_with_lsl/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
